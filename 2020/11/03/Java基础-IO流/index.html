<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java基础-IO流 | LAN</title><meta name="author" content="zlf"><meta name="copyright" content="zlf"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1.IO流(基本流)1.1 IO流介绍 IO流: 存储和读取数据的解决方案  File: 表示系统中文件或者文件夹的路径 只能对文件本身进行操作,不能读写文件里面存储的数据  IO流: 用于读写文件中的数据(可以读写文件,或网络中的数据…)   1.1.1 IO流的分类 根据流的方向分 输入流(读取)—文件-&gt;程序 输出流(写出)—程序-&gt;文件   根据操作文件的类型分 字节流: 可以">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础-IO流">
<meta property="og:url" content="https://xinyixy.github.io/2020/11/03/Java%E5%9F%BA%E7%A1%80-IO%E6%B5%81/index.html">
<meta property="og:site_name" content="LAN">
<meta property="og:description" content="1.IO流(基本流)1.1 IO流介绍 IO流: 存储和读取数据的解决方案  File: 表示系统中文件或者文件夹的路径 只能对文件本身进行操作,不能读写文件里面存储的数据  IO流: 用于读写文件中的数据(可以读写文件,或网络中的数据…)   1.1.1 IO流的分类 根据流的方向分 输入流(读取)—文件-&gt;程序 输出流(写出)—程序-&gt;文件   根据操作文件的类型分 字节流: 可以">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xinyixy.github.io/img/avatar.png">
<meta property="article:published_time" content="2020-11-03T02:35:41.000Z">
<meta property="article:modified_time" content="2023-06-22T20:48:40.429Z">
<meta property="article:author" content="zlf">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xinyixy.github.io/img/avatar.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://xinyixy.github.io/2020/11/03/Java%E5%9F%BA%E7%A1%80-IO%E6%B5%81/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/pluginsSrc/@fancyapps/ui/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: '/pluginsSrc/flickr-justified-gallery/dist/fjGallery.min.js',
      css: '/pluginsSrc/flickr-justified-gallery/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java基础-IO流',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-23 04:48:40'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 八音盒</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 皂片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于站长</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="LAN"><span class="site-name">LAN</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 八音盒</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 皂片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于站长</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java基础-IO流</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-11-03T02:35:41.000Z" title="发表于 2020-11-03 10:35:41">2020-11-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-22T20:48:40.429Z" title="更新于 2023-06-23 04:48:40">2023-06-23</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java基础-IO流"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1-IO流-基本流"><a href="#1-IO流-基本流" class="headerlink" title="1.IO流(基本流)"></a>1.IO流(基本流)</h2><h3 id="1-1-IO流介绍"><a href="#1-1-IO流介绍" class="headerlink" title="1.1 IO流介绍"></a>1.1 IO流介绍</h3><ul>
<li><p><strong>IO流: 存储和读取数据</strong>的解决方案</p>
</li>
<li><p><strong>File</strong>: 表示系统中文件或者文件夹的路径 只能<strong>对文件本身</strong>进行操作,<strong>不能读写文件里面存储的数据</strong></p>
</li>
<li><p><strong>IO流: 用于读写文件中的数据(可以读写文件,或网络中的数据…)</strong></p>
</li>
</ul>
<h4 id="1-1-1-IO流的分类"><a href="#1-1-1-IO流的分类" class="headerlink" title="1.1.1 IO流的分类"></a>1.1.1 IO流的分类</h4><ul>
<li>根据<strong>流的方向</strong>分<ul>
<li><strong>输入流(读取)</strong>—文件-&gt;程序</li>
<li><strong>输出流(写出)</strong>—程序-&gt;文件</li>
</ul>
</li>
<li>根据<strong>操作文件的类型</strong>分<ul>
<li><strong>字节流</strong>: 可以操作<strong>所有类型</strong>的文件</li>
<li><strong>字符流</strong>: 只可以操作<strong>纯文本文件</strong>—(纯文本文件: 用Windows系统自带的记事本打开并且能读懂的文件 如: txt md xml lrc等文件)</li>
</ul>
</li>
</ul>
<h4 id="1-1-2-IO流的分类"><a href="#1-1-2-IO流的分类" class="headerlink" title="1.1.2 IO流的分类"></a>1.1.2 IO流的分类</h4><ul>
<li>IO流体系(注意: 以下四种都是抽象类 不能直接创建对象)<ul>
<li>字节流<ul>
<li>InputStream—字节输入流</li>
<li>OutputStream—字节输出流</li>
</ul>
</li>
<li>字符流<ul>
<li>Reader—字符输入流</li>
<li>Writer—字符输出流</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1-2-FileOutputStream"><a href="#1-2-FileOutputStream" class="headerlink" title="1.2 FileOutputStream"></a>1.2 FileOutputStream</h3><ul>
<li><p><strong>字节流</strong></p>
<ul>
<li>OutputStream<ul>
<li><strong>FileOutputStream</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>操作本地文件的字节输出流</strong>,可以把程序中的数据写到本地文件中</p>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileOutputStreamDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            演示: 字节输出流FileOutputStream</span></span><br><span class="line"><span class="comment">            实现需求: 写出一段文字到本地文件中(暂时不写中文)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">             实现步骤:</span></span><br><span class="line"><span class="comment">                创建对象</span></span><br><span class="line"><span class="comment">                写出数据</span></span><br><span class="line"><span class="comment">                释放资源</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="comment">//括号里的参数是路径</span></span><br><span class="line">        FileOutputStream fos=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;src\\aaa\\a.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//写出数据到文件中</span></span><br><span class="line">        <span class="comment">//传递的数据是int类型的 它表示的是97在ASCII码表对应的字符</span></span><br><span class="line">        fos.write(<span class="number">97</span>);<span class="comment">//a</span></span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>细节</strong></p>
</li>
<li><p>1.创建字节输出流对象</p>
<ul>
<li>细节1: 参数是字符串表示的路径或者File对象都是可以的</li>
<li>细节2: 如果文件不存在会创建一个新的文件,但是要保证父级路径是存在的</li>
<li>细节3: 如果文件已经存在,则会清空文件</li>
</ul>
</li>
<li><p>2.写数据</p>
<ul>
<li>细节: write方法的参数是整数,但是实际上写到本地文件中的是整数在ASCII上对应的字符</li>
</ul>
</li>
<li><p>3.释放资源</p>
<ul>
<li>每次使用完流之后都要释放资源</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="1-2-1-FileOutputStream写数据的三种方式"><a href="#1-2-1-FileOutputStream写数据的三种方式" class="headerlink" title="1.2.1 FileOutputStream写数据的三种方式"></a>1.2.1 FileOutputStream写数据的三种方式</h4><table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void write(int b)</td>
<td>一次写一个字节数据</td>
</tr>
<tr>
<td>void write(byte[] b)</td>
<td>一次写一个字节数组数据</td>
</tr>
<tr>
<td>void write(byte[] b,int off,int len)</td>
<td>一次写一个字节数组的部分数据</td>
</tr>
</tbody></table>
<ul>
<li><p>代码实现</p>
</li>
<li><pre><code class="java">public class FileOutputStreamDemo &#123;
    public static void main(String[] args) throws IOException &#123;
        /*
            | void write(int b)                    | 一次写一个字节数据           |
            | void write(byte[] b)                 | 一次写一个字节数组数据       |
            | void write(byte[] b,int off,int len) | 一次写一个字节数组的部分数据 |
            参数一:
                数组
             参数二:
                起始索引 0
             参数三:
                个数 2
         */

        //创建对象
        //括号里的参数是路径
        //注意:如果原本文件里面就有内容,那么创建对象,会把原有的内容给清空
        FileOutputStream fos=new FileOutputStream(&quot;src\\aaa\\a.txt&quot;);
        //一次写一个字节数据
//        fos.write(97);

        //一次写一个字节数组数据
        byte[] bytes=&#123;97,98,99,100&#125;;
//        fos.write(bytes);//abcd
        //一次写一个字节数组的部分数据
        fos.write(bytes,1,2);//bc
        //释放资源
        fos.close();
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **换行写和续写**</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  public class FileOutputStreamDemo &#123;</span><br><span class="line">      public static void main(String[] args) throws IOException &#123;</span><br><span class="line">          /*</span><br><span class="line">              换行:</span><br><span class="line">                  再次写出一个换行符就可以了</span><br><span class="line">                  Windows: \r\n</span><br><span class="line">                  Linux: \n</span><br><span class="line">                  Mac: \r</span><br><span class="line">                 细节:在Windows系统中,java对回车换行进行了优化</span><br><span class="line">                 虽然完整的是\r\n,但是我们写其中一个\r或者\n也可以实现换行,因为在java底层会补全</span><br><span class="line">                 建议:</span><br><span class="line">                      不要忽略,还是写全</span><br><span class="line">              续写:</span><br><span class="line">                  如果想要续写,打开续写开关即可</span><br><span class="line">                  开关位置: 创建对象的第二个参数</span><br><span class="line">                  默认false: 表示关闭续写,此时创建对象会清空文件</span><br><span class="line">                  手动传递true: 表示打开续写,此时创建对象不会清空文件</span><br><span class="line">           */</span><br><span class="line">  </span><br><span class="line">          //创建对象</span><br><span class="line">          //括号里的参数是路径</span><br><span class="line">          //注意:我们创建对象时的第二个参数,决定原先文件里的内容是否清空,默认是false 表示再次创建对象时需要清空原先的内容</span><br><span class="line">          //如果我们不想清空原先的内容,把第二个参数改为true</span><br><span class="line">          FileOutputStream fos=new FileOutputStream(&quot;src\\aaa\\a.txt&quot;,true);</span><br><span class="line">  </span><br><span class="line">          //需求:此时我们想写字符串数据: wozuishuai</span><br><span class="line">          //但是write方法只能传递byte类型的数据,怎么办?</span><br><span class="line">          //我们先定义字符串,然后调用getBytes方法,返回一个字节数组,然后再写入</span><br><span class="line">          String s=&quot;wozuishuai&quot;;</span><br><span class="line">          byte[] bytes = s.getBytes();</span><br><span class="line">          fos.write(bytes);</span><br><span class="line">  </span><br><span class="line">          //换行</span><br><span class="line">          String s2=&quot;\r\n&quot;;</span><br><span class="line">          byte[] bytes1 = s2.getBytes();</span><br><span class="line">          fos.write(bytes1);</span><br><span class="line">  </span><br><span class="line">          String s3=&quot;666&quot;;</span><br><span class="line">          byte[] bytes2 = s3.getBytes();</span><br><span class="line">          fos.write(bytes2);</span><br><span class="line">          //释放资源</span><br><span class="line">          fos.close();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h3 id="1-3-FileInputStream"><a href="#1-3-FileInputStream" class="headerlink" title="1.3 FileInputStream"></a>1.3 FileInputStream</h3><ul>
<li><p><strong>字节流</strong></p>
<ul>
<li>InputStream<ul>
<li><strong>FileInputStream</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>操作本地文件的字节输入流,可以<strong>把本地文件中的数据读取到程序中来</strong></p>
</li>
<li><p><strong>细节</strong>:</p>
<ul>
<li><p><strong>1.创建字节输入流对象</strong></p>
<ul>
<li><strong>细节1: 如果文件不存在,则直接报错</strong></li>
</ul>
</li>
<li><p><strong>2.读数据</strong></p>
<ul>
<li><strong>细节1: 一次读一个字节,读出来的是数据在ASCII上对应的数字</strong></li>
<li><strong>细节2: 读到文件末尾了,read方法返回-1</strong></li>
</ul>
</li>
<li><p><strong>3.释放资源</strong></p>
<ul>
<li><strong>细节: 每次使用完流必须要释放资源</strong></li>
</ul>
</li>
<li><p>代码实现</p>
</li>
<li><pre><code class="java">public class FileInputStreamDemo &#123;
    public static void main(String[] args) throws IOException &#123;
        /*
        书写步骤:
              细节:
                1.创建字节输入流对象
                  细节1: 如果文件不存在,则直接报错
                  Java为什么这么设计呢?
                  输出流: 不存在则创建
                    把数据写到文件中

                  输入流: 不存在,而是报错呢?
                    因为创建出来的文件时没有数据的,没有任何意义
                    所以Java就没有设计这种无意义的逻辑,文件不存在直接报错

                  程序中最重要的是: 数据
                2.读数据
                  细节1: 一次读一个字节,读出来的是数据在ASCII上对应的数字
                  细节2: 读到文件末尾了,read方法返回-1
                3.释放资源
                  细节: 每次使用完流必须要释放资源
         */
        //1.创建字节输入流对象
        FileInputStream fis=new FileInputStream(&quot;src\\aaa\\a.txt&quot;);
        //2.读数据
        //一次只能读一个
        int b1 = fis.read();
        System.out.println(b1);
        //3.释放资源
        fis.close();
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **FileInputStream的循环读取**</span><br><span class="line"></span><br><span class="line">  ​	代码实现</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    public class FileInputStreamDemo &#123;</span><br><span class="line">        public static void main(String[] args) throws IOException &#123;</span><br><span class="line">            /*</span><br><span class="line">                字节输入流循环读取</span><br><span class="line">                read: 表示读取数据,而且是读取一个数据就移动一次指针</span><br><span class="line">             */</span><br><span class="line">            //1.创建字节输入流对象</span><br><span class="line">            FileInputStream fis=new FileInputStream(&quot;src\\aaa\\a.txt&quot;);</span><br><span class="line">           //因为一次只能读取一个数据,为了读取数据的效率,我们用循环实现</span><br><span class="line">    </span><br><span class="line">            //定义第三方变量,来存储读取到的数据</span><br><span class="line">            int b=0;</span><br><span class="line">            //将读取到的数据赋值给b,因为读取到最后read方法返回-1,</span><br><span class="line">            //所以如果数据不等于-1 那么就打印读取到的数据</span><br><span class="line">            while ((b=fis.read())!=-1)&#123;</span><br><span class="line">                //因为b是int类型的,我们如果想要看到具体的数据,需要进行数据类型转换</span><br><span class="line">                System.out.print((char) b);</span><br><span class="line">                //wozuishuai</span><br><span class="line">                //666</span><br><span class="line">            &#125;</span><br><span class="line">            //3.释放资源</span><br><span class="line">            fis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="1-3-1-FileInputStream一次读多个字节"><a href="#1-3-1-FileInputStream一次读多个字节" class="headerlink" title="1.3.1 FileInputStream一次读多个字节"></a>1.3.1 FileInputStream一次读多个字节</h4><ul>
<li><table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public  int  read()</td>
<td>一次读一个字节数据</td>
</tr>
<tr>
<td>public  int  read(byte[]  buffer)</td>
<td>一次读一个字节数组数据</td>
</tr>
</tbody></table>
<p>注意: 一次读一个字节数组的数据,每次读取会尽可能把数组装满</p>
</li>
<li><p>代码实现</p>
</li>
<li><pre><code class="java">public class FileInputStreamDemo2 &#123;
    public static void main(String[] args) throws IOException &#123;
        /*
        public  int  read(byte[]  buffer)一次读一个字节数组数据

        注:
        b.txt里面的内容:nihao
         */
        //创建对象
        FileInputStream fis=new FileInputStream(&quot;src\\aaa\\b.txt&quot;);
        //读取数据
        //一次读多少个字节数据,具体读多少,跟数组的长度有关,如果为2 表示一次读2个数据
        byte[] bytes=new byte[2];
        //调用带参的read方法读取数据
        int len1 = fis.read(bytes);
        //返回值: 本次读取到了多少个字节数据

        //打印读取到的个数
        System.out.println(len1);//2
        //把byte数组里面的数据变成字符串并打印
        String s1=new String(bytes);
        System.out.println(s1);//ni

        //第二次读取
        int len2 = fis.read(bytes);
        System.out.println(len2);//2
        //把byte数组里面的数据变成字符串并打印
        String s2=new String(bytes);
        System.out.println(s2);//ha

        //第三次读取
        int len3 = fis.read(bytes);
        System.out.println(len3);//2
        //为什么第三次的时候明明还剩下一个数据,但是实际上确是读取了两个呢?
        //因为: 每一次读取会尽可能的把数组填满,而且每一次读取都会覆盖数据
        // 第二次读取之后,数组中存储的是 ha
        //第三次开始读取之后,因为只剩下一个数据o 所以o会把h覆盖掉 a会保留
        //所以此时是两个数据oa
        //把byte数组里面的数据变成字符串并打印
        String s3=new String(bytes);
        System.out.println(s3);//o

        //为了让读取到的数据不被影响,这样写:
        //String s=new String(bytes,0,len);
        //这就表示,我们每次都按照len个 来进行读取数据
        //释放资源
        fis.close();
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 练习: 文件拷贝</span><br><span class="line"></span><br><span class="line">- 代码实现</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  public class FileInputStreamDemo1 &#123;</span><br><span class="line">      public static void main(String[] args) throws IOException &#123;</span><br><span class="line">          /*</span><br><span class="line">          练习:</span><br><span class="line">              文件拷贝</span><br><span class="line">              把E:\JavaStudy\File\b.txt拷贝到src\aaa下</span><br><span class="line">  </span><br><span class="line">           */</span><br><span class="line">          //创建对象</span><br><span class="line">          //先读再写</span><br><span class="line">          FileInputStream fis=new FileInputStream(&quot;E:\\JavaStudy\\File\\b.txt&quot;);</span><br><span class="line">          FileOutputStream fos=new FileOutputStream(&quot;src\\aaa\\b.txt&quot;);</span><br><span class="line">         //拷贝数据</span><br><span class="line">          //就是边读边写</span><br><span class="line">          //定义每次读取到的数据个数</span><br><span class="line">          int len;</span><br><span class="line">          //定义数组,把读取到的数据存到数组中</span><br><span class="line">          //我们在定义数组长度的时候,一般会用1024的整数倍</span><br><span class="line">          //1024=1kb </span><br><span class="line">          byte[] bytes=new byte[1024];</span><br><span class="line">          while ((len=fis.read(bytes))!=-1)&#123;</span><br><span class="line">              fos.write(bytes,0,len);</span><br><span class="line">          &#125;</span><br><span class="line">          //释放资源</span><br><span class="line">          //先开的最后关闭</span><br><span class="line">          fos.close();</span><br><span class="line">          fis.close();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h3 id="1-4-在IO流中异常处理方案–try…catch…finally-了解-能看懂代码即可"><a href="#1-4-在IO流中异常处理方案–try…catch…finally-了解-能看懂代码即可" class="headerlink" title="1.4 在IO流中异常处理方案–try…catch…finally(了解,能看懂代码即可)"></a>1.4 在IO流中异常处理方案–try…catch…finally(了解,能看懂代码即可)</h3><p><strong>特点: finally里面的代码一定被执行,除非虚拟机停止</strong></p>
<p><strong>接口: AutoCloseable—特定的情况下,可以自动释放资源</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> 基本做法:						</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    可能出现异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>&#123;</span><br><span class="line">    异常的处理代码</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    执行所有资源释放操作</span><br><span class="line">&#125;</span><br><span class="line">手动释放资源</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JDK7方案:					</span><br><span class="line"><span class="keyword">try</span>(创建对象<span class="number">1</span>;创建对象<span class="number">2</span>)&#123;</span><br><span class="line">    可能出现异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>&#123;</span><br><span class="line">    异常的处理代码</span><br><span class="line">&#125;</span><br><span class="line">资源用完最终自动释放</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JDK9方案:		</span><br><span class="line">创建对象<span class="number">1</span>;</span><br><span class="line">创建对象<span class="number">2</span>;</span><br><span class="line"><span class="keyword">try</span>(对象<span class="number">1</span>;对象<span class="number">2</span>)&#123;</span><br><span class="line">    可能出现异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>&#123;</span><br><span class="line">    异常的处理代码</span><br><span class="line">&#125;</span><br><span class="line">资源用完最终自动释放</span><br></pre></td></tr></table></figure>



<h3 id="1-6-字符集"><a href="#1-6-字符集" class="headerlink" title="1.6 字符集"></a>1.6 字符集</h3><ul>
<li><p>字节流读取文件时,文件中不要有中文,否则会乱码</p>
</li>
<li><p>存储英文,一字节就足以</p>
</li>
<li><p>1.计算机的存储规则(英文)—ASCII集</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img%5Ceg.jpg"></p>
<ul>
<li><p><strong>GBK字符集</strong>:包含国家标准的全部中日韩汉字以及台湾地区BIG5(繁体)中的所有汉字</p>
<ul>
<li><strong>Windows系统默认使用的就是GBK,系统显示: ANSI</strong></li>
</ul>
</li>
<li><p>2.1计算机的存储规则(英文)(GBK)</p>
<ul>
<li><strong>规则: 英文一个字节存储,兼容ASCII,二进制前面补0</strong></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img%5CGBKe.jpg"></p>
</li>
<li><p>2.2计算机的存储规则(汉字)(GBK)</p>
<ul>
<li><strong>一个汉字两个字节存储</strong></li>
<li><strong>高位字节二进制一定以1开头,转成十进制之后是一个负数</strong></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img%5CGBKc.jpg" alt="GBKc"></p>
</li>
<li><p>练习: 看编码说结果</p>
<ul>
<li>以下为GBK字符集中编码之后的二进制,请说出有几个中文,几个英文</li>
<li>1: 10111010  10111010  01100001</li>
<li>一个中文 一个英文 : 中文以1开头 且是两个字节 英文以0开头</li>
</ul>
</li>
<li><h3 id="掌握"><a href="#掌握" class="headerlink" title="掌握:"></a><strong>掌握:</strong></h3><ul>
<li>1.在计算机中,任意数据都是以二进制的形式来存储的</li>
<li>2.计算机中最小的存储单元是一个字节</li>
<li><strong>3.ASCII字符集中,一个英文占一个字节</strong></li>
<li><strong>4.简体中文版Windows,默认使用GBK字符集</strong></li>
<li><strong>5.GBK字符集完全兼容ASCII字符集</strong><ul>
<li><strong>一个英文占一个字节,二进制第一位是0</strong></li>
<li><strong>一个中文占两个字节,二进制高位字节(开头)第一位是1</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Unicode字符集</strong>(万国码): 国际标准字符串,它将世界各种语言的每个字符定义一个唯一的编码,以满足跨语言、跨平台的文本信息转换</p>
</li>
<li><p>3.1计算机的存储规则(英文)(Unicode)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img%5Cunie.jpg"></p>
</li>
<li><p>3.2计算机的存储规则(英文)(Unicode)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img%5Cunic.jpg" alt="unic"></p>
</li>
<li><h3 id="掌握-1"><a href="#掌握-1" class="headerlink" title="掌握:"></a>掌握:</h3><ul>
<li><strong>Unicode字符集的UTF-8 的编码规则:</strong><ul>
<li><strong>一个英文占一个字节,二进制第一位是0,转成十进制是正数</strong></li>
<li><strong>一个中文占三个字节,二进制第一位是1,第一个字节转成十进制是负数</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="1-6-1-乱码"><a href="#1-6-1-乱码" class="headerlink" title="1.6.1 乱码"></a>1.6.1 乱码</h4><ul>
<li><p><strong>为什么会有乱码?</strong></p>
<ul>
<li>1.读取数据时未读完整个汉字</li>
<li>2.编码和解码时的方式不统一</li>
</ul>
</li>
<li><p><strong>如何不产生乱码?</strong></p>
<ul>
<li><strong>1.不要使用字节流读取(包含中文的)文本文件</strong></li>
<li><strong>2.编码解码时使用同一个码表,同一个编码方式</strong></li>
</ul>
</li>
<li><p><strong>问: 字节流读取中文会乱码,但是为什么拷贝不会乱码呢?</strong></p>
<ul>
<li><strong>在拷贝时,数据没有丢失</strong></li>
</ul>
</li>
</ul>
<p>1.6.2 Java中编码和解码的实现</p>
<ul>
<li>编码方法</li>
</ul>
<table>
<thead>
<tr>
<th>String类中的方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public  byte[ ]  getBytes()</td>
<td>使用默认方式进行编码</td>
</tr>
<tr>
<td>public  byte[ ]  getBytes(String  charsetName)</td>
<td>使用指定方式进行编码</td>
</tr>
</tbody></table>
<ul>
<li>解码方法</li>
</ul>
<table>
<thead>
<tr>
<th>String类中的方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>String(byte[ ]  bytes)</td>
<td>使用默认方式进行解码</td>
</tr>
<tr>
<td>String(byte[ ]  bytes,String  charsetName)</td>
<td>使用指定方式进行解码</td>
</tr>
</tbody></table>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharSetDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        - 编码方法</span></span><br><span class="line"><span class="comment">        | public  byte[ ]  getBytes()                    | 使用默认方式进行编码 |</span></span><br><span class="line"><span class="comment">        | public  byte[ ]  getBytes(String  charsetName) | 使用指定方式进行编码 |</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        - 解码方法</span></span><br><span class="line"><span class="comment">        | String(byte[ ]  bytes)                     | 使用默认方式进行解码 |</span></span><br><span class="line"><span class="comment">        | String(byte[ ]  bytes,String  charsetName) | 使用指定方式进行解码 |</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//1.编码</span></span><br><span class="line">        String s=<span class="string">&quot;a你好&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] bytes = s.getBytes();<span class="comment">//空参,表示默认编码方式 在idea中是UTF-8编码  在eclipse中是GBK编码</span></span><br><span class="line">        System.out.println(Arrays.toString(bytes));<span class="comment">//[97, -28, -67, -96, -27, -91, -67]</span></span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] bytes1 = s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(bytes1));<span class="comment">//[97, -60, -29, -70, -61]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.解码</span></span><br><span class="line">        <span class="comment">//UTF-8</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes);</span><br><span class="line">        System.out.println(s1);<span class="comment">//a你好</span></span><br><span class="line">        <span class="comment">//GBK</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        System.out.println(s2);<span class="comment">//a浣犲ソ</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-7-字符流"><a href="#1-7-字符流" class="headerlink" title="1.7 字符流"></a>1.7 字符流</h3><ul>
<li><strong>字符流的底层其实就是字节流</strong></li>
<li><strong>字符流 &#x3D; 字节流  + 字符集</strong></li>
<li>特点: <ul>
<li><strong>输入流: 一次读一个字节,遇到中文时,一次读多个字节</strong></li>
<li><strong>输出流: 底层会把数据按照指定的编码方式进行编码,变成字节再写到文件中</strong></li>
</ul>
</li>
<li>使用场景<ul>
<li><strong>对于纯文本文件进行读写操作</strong></li>
</ul>
</li>
<li>体系结构:</li>
<li>字符流<ul>
<li>Reader<ul>
<li><strong>FileReader—操作本地文件的字符输入流</strong></li>
</ul>
</li>
<li>Writer<ul>
<li><strong>FileWriter—操作本地文件的字符输出流</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="1-7-1-FileReader"><a href="#1-7-1-FileReader" class="headerlink" title="1.7.1 FileReader"></a>1.7.1 FileReader</h4><ul>
<li><p>读文件:</p>
</li>
<li><ol>
<li>创建字符输入流对象</li>
</ol>
<table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public  FileReader(File  file)</td>
<td>创建字符输入流关联本地文件</td>
</tr>
<tr>
<td>public  FileReader(String  pathname)</td>
<td>创建字符输入流关联本地文件</td>
</tr>
</tbody></table>
</li>
<li><ol start="2">
<li>读取数据</li>
</ol>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public  int  read( )</td>
<td>读取数据,读到末尾返回-1</td>
</tr>
<tr>
<td>public  int  read( char[ ]  buffer )</td>
<td>读取多个数据,读到末尾返回-1</td>
</tr>
</tbody></table>
<p>细节1: 按字节进行读取,遇到中文,一次读多个字节,读取后解码,返回一个整数</p>
<p>细节2: 读到文件末尾了,read方法返回-1</p>
</li>
<li><ol start="3">
<li>释放资源</li>
</ol>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public  void  flush( )</td>
<td>将缓冲区中的数据,刷新到本地文件中</td>
</tr>
<tr>
<td>public  void  close( )</td>
<td>释放资源&#x2F;关流</td>
</tr>
</tbody></table>
<p><strong>flush刷新: 刷新之后,还可以继续往文件中写出数据</strong></p>
<p><strong>close关流: 断开通道,无法再往文件中写出数据</strong></p>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReaderDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            - 1. 创建字符输入流对象</span></span><br><span class="line"><span class="comment">                  | public  FileReader(File  file)       | 创建字符输入流关联本地文件 |</span></span><br><span class="line"><span class="comment">                  | public  FileReader(String  pathname) | 创建字符输入流关联本地文件 |</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                - 2. 读取数据</span></span><br><span class="line"><span class="comment">                  | public  int  read( )                 | 读取数据,读到末尾返回-1     |</span></span><br><span class="line"><span class="comment">                  | public  int  read( char[ ]  buffer ) | 读取多个数据,读到末尾返回-1 |</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                - 3. 释放资源</span></span><br><span class="line"><span class="comment">                  | public  int  close( ) | 释放资源/关流 |</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//1.创建对象</span></span><br><span class="line">        FileReader fr=<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;src\\aaa\\c.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//2.调用read空参方法读取文件数据</span></span><br><span class="line">        <span class="comment">//字符流底层也是字节流,默认也是一个字节一个字节的读取的</span></span><br><span class="line">        <span class="comment">//如果遇到中文就会一次读取多个,GBK一次读两个字节,UTF-8一次读三个字节</span></span><br><span class="line">        <span class="type">int</span> r=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            read() 细节:</span></span><br><span class="line"><span class="comment">                1.read(): 默认也是一个字节一个字节的读取,如果遇到中文就会一次读取多个</span></span><br><span class="line"><span class="comment">                2.在读取之后,方法的底层还会进行解码并转成十进制 最终把这个十进制作为返回值,</span></span><br><span class="line"><span class="comment">                这个十进制的数据也表示在字符集上的数字</span></span><br><span class="line"><span class="comment">                英文: 文件里面二进制数据 0110 0001</span></span><br><span class="line"><span class="comment">                    read方法进行读取,解码并转成十进制97</span></span><br><span class="line"><span class="comment">                中文: 文件里面的二进制数据 11100110 1011001 10001001</span></span><br><span class="line"><span class="comment">                    read方法进行读取,解码并转成十进制27721</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> ((r=fr.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//我想看到中文汉字,就是把十进制数据,再进行强转</span></span><br><span class="line">            System.out.print((<span class="type">char</span>) r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.释放资源</span></span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>有参read方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReaderDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            - 1. 创建字符输入流对象</span></span><br><span class="line"><span class="comment">                  | public  FileReader(File  file)       | 创建字符输入流关联本地文件 |</span></span><br><span class="line"><span class="comment">                  | public  FileReader(String  pathname) | 创建字符输入流关联本地文件 |</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                - 2. 读取数据</span></span><br><span class="line"><span class="comment">                  | public  int  read( )                 | 读取数据,读到末尾返回-1     |</span></span><br><span class="line"><span class="comment">                  | public  int  read( char[ ]  buffer ) | 读取多个数据,读到末尾返回-1 |</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                - 3. 释放资源</span></span><br><span class="line"><span class="comment">                  | public  int  close( ) | 释放资源/关流 |</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//1.创建对象</span></span><br><span class="line">        FileReader fr=<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;src\\aaa\\c.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.调用带参read方法</span></span><br><span class="line">        <span class="comment">//char数组长度为2 表示一次读取两个数据</span></span><br><span class="line">        <span class="type">char</span>[] chars=<span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//这里的len表示读取到的数据个数</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            read(chars): 读取数据,解码,强转三步合并了,把强转之后的字符放到数组当中</span></span><br><span class="line"><span class="comment">            相当于 空参的read+强转类型转换</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> ((len=fr.read(chars))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//把char类型的数据转换为string类型的并进行打印</span></span><br><span class="line">            <span class="comment">//一次打印两个数据,遇到\r\n也算,\r不表现出来,遇到\n会换行</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(chars,<span class="number">0</span>,len));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.释放资源</span></span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="1-7-2-FileWriter"><a href="#1-7-2-FileWriter" class="headerlink" title="1.7.2 FileWriter"></a>1.7.2 FileWriter</h4><ul>
<li><p>构造方法</p>
<table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public  FileWriter(File  file)</td>
<td>创建字符输出流关联本地文件</td>
</tr>
<tr>
<td>public  FileWriter(String  pathname)</td>
<td>创建字符输出流关联本地文件</td>
</tr>
<tr>
<td>public  FileWriter(File  file, boolean  append)</td>
<td>创建字符输出流关联本地文件,续写</td>
</tr>
<tr>
<td>public  FileWriterString pathname,boolean append)</td>
<td>创建字符输出流关联本地文件,续写</td>
</tr>
</tbody></table>
</li>
<li><p>成员方法</p>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void  write(int  c)</td>
<td>写出一个字符</td>
</tr>
<tr>
<td>void  write(String  str)</td>
<td>写出一个字符串</td>
</tr>
<tr>
<td>void  write(String  str, int off, int len)</td>
<td>写出一个字符串的一部分</td>
</tr>
<tr>
<td>void  write(char[ ] cbuf)</td>
<td>写出一个字符数组</td>
</tr>
<tr>
<td>void  write(char[ ] cbuf,int off,int len)</td>
<td>写出字符数组的一部分</td>
</tr>
</tbody></table>
</li>
<li><p>书写细节:</p>
</li>
<li><p>1.创建字符输出流对象</p>
<ul>
<li><strong>细节1: 参数是字符串表示的路径或者File对象都是可以的</strong></li>
<li><strong>细节2: 如果文件不存在会创建一个新的文件,但是要保证父级路径是存在的</strong></li>
<li><strong>细节3: 如果文件已经存在,则会清空文件,如果不想清空可以打开续写开关</strong></li>
</ul>
</li>
<li><p>2.写数据</p>
<ul>
<li><strong>细节: 如果write方法的参数是整数,但是实际上写到本地文件中的整数在字符集上对应的字符</strong></li>
</ul>
</li>
<li><p>3.释放资源</p>
<ul>
<li><strong>细节: 每次使用完流之后都要释放资源</strong></li>
</ul>
</li>
<li><p>代码实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileWriterDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        | void  write(int  c)                        | 写出一个字符           |</span></span><br><span class="line"><span class="comment">        | void  write(String  str)                   | 写出一个字符串         |</span></span><br><span class="line"><span class="comment">        | void  write(String  str, int off, int len) | 写出一个字符串的一部分 |</span></span><br><span class="line"><span class="comment">        | void  write(char[ ] cbuf)                  | 写出一个字符数组       |</span></span><br><span class="line"><span class="comment">        | void  write(char[ ] cbuf,int off,int len)  | 写出字符数组的一部分   |</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//1/创建对象 构造方法第二个参数为续写开关,true表示打开续写开关</span></span><br><span class="line">        FileWriter fw=<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;src\\aaa\\d.txt&quot;</span>,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.1 写出一个字符</span></span><br><span class="line">        <span class="comment">//根据字符集的编码方式进行编码,把编码之后的数据写到文件中去</span></span><br><span class="line">        <span class="comment">//UTF-8</span></span><br><span class="line">       <span class="comment">// fw.write(25105);//我</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.2 写出一个字符串</span></span><br><span class="line">        <span class="comment">//fw.write(&quot;你好呀aaa&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.3写出一个字符串的一部分</span></span><br><span class="line"><span class="comment">//        String s=&quot;hello你好世界&quot;;</span></span><br><span class="line"><span class="comment">//        fw.write(s,0,6);//hello你</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.4写出一个字符数组</span></span><br><span class="line">        <span class="type">char</span>[] chars=&#123;<span class="string">&#x27;你&#x27;</span>,<span class="string">&#x27;好&#x27;</span>,<span class="string">&#x27;啊&#x27;</span>&#125;;</span><br><span class="line"><span class="comment">//        fw.write(chars);//你好啊</span></span><br><span class="line">        <span class="comment">//2.5写出字符数组的一部分</span></span><br><span class="line">        fw.write(chars,<span class="number">0</span>,<span class="number">1</span>);<span class="comment">//你</span></span><br><span class="line">        <span class="comment">//3.释放资源</span></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>字节流和字符流的使用场景</strong></p>
<p><strong>字节流:</strong> </p>
<p>​		拷贝<strong>任意类型</strong>的文件</p>
<p><strong>字符流:</strong></p>
<p>​		读取<strong>纯文本文件</strong>中的数据</p>
<p>​		往<strong>纯文本文件</strong>中写出数据</p>
<h3 id="1-8-练习"><a href="#1-8-练习" class="headerlink" title="1.8  练习"></a>1.8  练习</h3><ul>
<li><p>1.拷贝文件夹 考虑子文件夹</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOTestDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">           拷贝文件夹,需要考虑子文件夹</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//创建数据源对象</span></span><br><span class="line">        File src=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\JavaStudy\\File&quot;</span>);</span><br><span class="line">        <span class="comment">//创建目标文件对象</span></span><br><span class="line">        File end=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\JavaStudy\\File1&quot;</span>);</span><br><span class="line">        <span class="comment">//调用函数,拷贝文件</span></span><br><span class="line">        copyFile(src,end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFile</span><span class="params">(File src, File end)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//当目标文件夹为空时,创建新的</span></span><br><span class="line">        end.mkdirs();</span><br><span class="line">        <span class="comment">//进入数据源 得到一个file数组</span></span><br><span class="line">        File[] files = src.listFiles();</span><br><span class="line">        <span class="comment">//用增强for遍历数组,得到每一个文件或文件夹</span></span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="comment">//判断文件,拷贝</span></span><br><span class="line">                <span class="keyword">if</span> (file.isFile())&#123;</span><br><span class="line">                    <span class="comment">//拷贝 边读边写</span></span><br><span class="line">                    <span class="comment">//拷贝的文件路径: 从文件开始到文件结束</span></span><br><span class="line">                    <span class="comment">//注意: 此时file是数据源文件夹里面 每一个文件或文件夹的路径</span></span><br><span class="line">                    FileInputStream fis=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">                    <span class="comment">//把file拷贝到end文件夹里面 </span></span><br><span class="line">                    FileOutputStream fos=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(end,file.getName()));</span><br><span class="line">                    <span class="comment">//这里选择byte数组,因为用数组更快</span></span><br><span class="line">                    <span class="type">byte</span>[] bytes=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                    <span class="type">int</span> len;</span><br><span class="line">                    <span class="keyword">while</span> ((len=fis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                        fos.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//释放资源  注意: 先开启的要后关闭</span></span><br><span class="line">                    fos.close();</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果是文件夹,递归</span></span><br><span class="line">                    copyFile(file,<span class="keyword">new</span> <span class="title class_">File</span>(end,file.getName()));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2.文件加密</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOTestDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          文件加密:</span></span><br><span class="line"><span class="comment">            为了保证文件的安全性,就需要对原始文件进行加密存储,再使用的时候再对其进行解密处理</span></span><br><span class="line"><span class="comment">            加密原理:</span></span><br><span class="line"><span class="comment">                对原始文件中的每一个字节数据进行更改,然后将更改以后的数据存储到新的文件中</span></span><br><span class="line"><span class="comment">            解密原理:</span></span><br><span class="line"><span class="comment">                读取加密之后的文件,按照加密的规则反向操作,变成原始文件</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">             ^ : 异或符号</span></span><br><span class="line"><span class="comment">                 两边相同: false</span></span><br><span class="line"><span class="comment">                 两边不同: true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">             例子:</span></span><br><span class="line"><span class="comment">                  System.out.println(100^10);//110</span></span><br><span class="line"><span class="comment">                  System.out.println(110^10);//100</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建对象,关联原始文件</span></span><br><span class="line">        FileInputStream fis=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\aaa\\1.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">//创建对象,关联加密文件</span></span><br><span class="line">        <span class="comment">//加密完成后,文件2不能看</span></span><br><span class="line">        <span class="comment">//如果想再解密 更改文件路径即可 把fis的改成fos的 fos的换成新的</span></span><br><span class="line">        FileOutputStream fos=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;src\\aaa\\2.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">//用^进行加密</span></span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        <span class="keyword">while</span> ((b=fis.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//加密 这里的数字随便写</span></span><br><span class="line">            fos.write(b^<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-IO流-高级流"><a href="#2-IO流-高级流" class="headerlink" title="2.IO流(高级流)"></a>2.IO流(高级流)</h2><h3 id="2-1-缓冲流"><a href="#2-1-缓冲流" class="headerlink" title="2.1 缓冲流"></a>2.1 缓冲流</h3><ul>
<li>高级流就是在基本流的基础上加一个<strong>缓冲区</strong>,来提高效率</li>
<li>缓冲流<ul>
<li><p><strong>字节缓冲流</strong></p>
<ul>
<li><p>BufferedInputStream—字节缓冲输入流</p>
</li>
<li><p>BufferedOutputStream—字节缓冲输出流</p>
</li>
</ul>
</li>
<li><p><strong>字符缓冲流</strong></p>
<ul>
<li><p>BufferedReader—字符缓冲输入流</p>
</li>
<li><p>BufferedWriter—字符缓冲输出流</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-1-1-字节缓冲流"><a href="#2-1-1-字节缓冲流" class="headerlink" title="2.1.1 字节缓冲流"></a>2.1.1 字节缓冲流</h4><ul>
<li><p>方法介绍</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public BufferedInputStream(InputStream  is)</td>
<td>把基本流包装成高级流,提高读取数据的性能</td>
</tr>
<tr>
<td>public BufferedOutputStream(OutputStream  os)</td>
<td>把基本流包装成高级流,提高读取数据的性能</td>
</tr>
</tbody></table>
</li>
<li><p>原理: 底层自带了长度为8192的缓冲区提高性能</p>
</li>
<li><p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedStreamDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          使用字节缓冲流拷贝文件</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">          字节缓冲输入流的构造方法</span></span><br><span class="line"><span class="comment">        | public BufferedInputStream(InputStream  is)   | 把基本流包装成高级流,提高读取数据的性能 |</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         字节缓冲输出流的构造方法</span></span><br><span class="line"><span class="comment">        | public BufferedOutputStream(OutputStream  os) | 把基本流包装成高级流,提高读取数据的性能 |</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        BufferedInputStream bis=<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\aaa\\c.txt&quot;</span>));</span><br><span class="line">        BufferedOutputStream bos=<span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;src\\aaa\\copy.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//拷贝文件</span></span><br><span class="line">        <span class="comment">//一次读写一个字节</span></span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        <span class="keyword">while</span> ((b=bis.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            bos.write(b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        bos.close();</span><br><span class="line">        bis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一次读取多个字节—示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedStreamDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          使用字节缓冲流拷贝文件</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">          字节缓冲输入流的构造方法</span></span><br><span class="line"><span class="comment">        | public BufferedInputStream(InputStream  is)   | 把基本流包装成高级流,提高读取数据的性能 |</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         字节缓冲输出流的构造方法</span></span><br><span class="line"><span class="comment">        | public BufferedOutputStream(OutputStream  os) | 把基本流包装成高级流,提高读取数据的性能 |</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        BufferedInputStream bis=<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\aaa\\c.txt&quot;</span>));</span><br><span class="line">        BufferedOutputStream bos=<span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;src\\aaa\\copy.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//拷贝文件</span></span><br><span class="line">        <span class="comment">//一次读写多个字节</span></span><br><span class="line">        <span class="type">byte</span>[] bytes=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len=bis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            bos.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        bos.close();</span><br><span class="line">        bis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-1-2-字符缓冲流"><a href="#2-1-2-字符缓冲流" class="headerlink" title="2.1.2 字符缓冲流"></a>2.1.2 字符缓冲流</h4><ul>
<li><p><strong>原理: 底层自带了长度为8192的缓冲区提高性能</strong></p>
</li>
<li><p>构造方法</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public  BufferedReader(Reader  r)</td>
<td>把基本流变成高级流</td>
</tr>
<tr>
<td>public  BufferedWriter(Writer  r)</td>
<td>把基本流变成高级流</td>
</tr>
</tbody></table>
</li>
<li><p><strong>字符缓冲流特有方法</strong></p>
<table>
<thead>
<tr>
<th>字符缓冲输入流特有方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public  String <strong>readLine</strong>()</td>
<td><strong>读取一行数据</strong>,如果没有数据可读了,会返回null</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedStreamDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">           字符缓冲输入流</span></span><br><span class="line"><span class="comment">           public  BufferedReader(Reader  r)    把基本流变成高级流</span></span><br><span class="line"><span class="comment">           public  String  readLine()       读取一行数据,如果没有数据可读了,会返回null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        BufferedReader br=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;src\\aaa\\c.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//读取数据(读一行数据)</span></span><br><span class="line"><span class="comment">//        String s = br.readLine();</span></span><br><span class="line"><span class="comment">//        System.out.println(s);//我的朋友们</span></span><br><span class="line">        <span class="comment">//读取文件的全部数据</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">           读取数据的细节:</span></span><br><span class="line"><span class="comment">           readLine方法在读取的时候,一次读一整行,遇到回车换行结束</span></span><br><span class="line"><span class="comment">           //但是它不会把回车换行读到内存中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span> ((s=br.readLine())!=<span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>字符缓冲输出流特有方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public  void  <strong>newLine</strong>()</td>
<td>跨平台的换行</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedStreamDemo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">           字符缓冲输出流</span></span><br><span class="line"><span class="comment">           public  BufferedWriter(Writer  r)    把基本流变成高级流</span></span><br><span class="line"><span class="comment">           public  void  newLine()              跨平台的换行</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="comment">//注意此时的续写开关还是写在基本流里面</span></span><br><span class="line">        BufferedWriter bw=<span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;src\\aaa\\b.txt&quot;</span>,<span class="literal">true</span>));</span><br><span class="line">        <span class="comment">//写出数据</span></span><br><span class="line">        bw.write(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">        <span class="comment">//跨平台换行</span></span><br><span class="line">        bw.newLine();</span><br><span class="line">        bw.write(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>缓冲流为什么能提高性能</strong></p>
<ul>
<li><strong>缓冲流自带长度为8192的缓冲区</strong></li>
<li><strong>可以显著提高字节流的读写性能</strong></li>
<li><strong>对于字符流提升不明显,对于字符缓冲流而言关键点是两个特有的方法</strong></li>
</ul>
</li>
</ul>
<h4 id="2-1-3-练习"><a href="#2-1-3-练习" class="headerlink" title="2.1.3 练习"></a>2.1.3 练习</h4><ul>
<li><p>四种拷贝方式效率对比</p>
<p>字节流的基本流: 一次读写一个字节</p>
<p>字节流的基本流: 一次读写一个字节数组</p>
<p>字节缓冲流: 一次读写一个字节</p>
<p>字节缓冲流: 一次读写一个字节数组</p>
</li>
<li><p>以后如果要<strong>拷贝文件</strong>:</p>
<ul>
<li>选择第二种(<strong>字节流的基本流: 一次读写一个字节数组</strong>)或者第四种(<strong>字节缓冲流: 一次读写一个字节数组</strong>)都是可以的</li>
</ul>
</li>
<li><p>代码演示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedTestDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        四种拷贝方式效率对比</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        字节流的基本流: 一次读写一个字节</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        字节流的基本流: 一次读写一个字节数组</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        字节缓冲流: 一次读写一个字节</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        字节缓冲流: 一次读写一个字节数组</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        &quot;E:\\JavaStudy\\File\\roseSong.mp3&quot;</span></span><br><span class="line"><span class="comment">        拷贝到 src\\aaa下</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">long</span> start=System.currentTimeMillis();</span><br><span class="line"><span class="comment">//        method1();//0.604秒</span></span><br><span class="line"><span class="comment">//        method2();//0.001秒</span></span><br><span class="line"><span class="comment">//        method3();//0.019秒</span></span><br><span class="line">        method4();<span class="comment">//0.002秒</span></span><br><span class="line">        <span class="type">long</span> end=System.currentTimeMillis();</span><br><span class="line">        System.out.println((end-start) / <span class="number">1000.0</span> +<span class="string">&quot;秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//字节流的基本流: 一次读写一个字节数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        FileInputStream fis=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;E:\\JavaStudy\\File\\互联网+项目计划书.docx&quot;</span>);</span><br><span class="line">        FileOutputStream fos=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;src\\aaa\\互联网+项目计划书.docx&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] bytes=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len=fis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        fos.close();</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字节缓冲流: 一次读写一个字节数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method4</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        BufferedInputStream bis=<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;E:\\JavaStudy\\File\\互联网+项目计划书.docx&quot;</span>));</span><br><span class="line">        BufferedOutputStream bos=<span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;src\\aaa\\互联网+项目计划书.docx&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[] bytes=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len=bis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            bos.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        bos.close();</span><br><span class="line">        bis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-2-转换流"><a href="#2-2-转换流" class="headerlink" title="2.2 转换流"></a>2.2 转换流</h3><ul>
<li><p><strong>转换流属于字符流,是字符流和字节流之间的桥梁</strong></p>
</li>
<li><p><strong>InputStreamReader</strong>—父类为Reader</p>
<ul>
<li><strong>将字节流转换为字符流</strong></li>
</ul>
</li>
<li><p><strong>OutputStreamWriter</strong>—父类为Writer</p>
<ul>
<li>将字符流转换为字节流</li>
</ul>
</li>
<li><p><strong>作用:</strong></p>
<ul>
<li><p>1: 指定字符集读写(JDK11淘汰),<strong>替代方案(掌握)</strong></p>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com_02.IOBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConvertStreamDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            利用转换流按照指定字符集读取(了解)</span></span><br><span class="line"><span class="comment">            因为JDK11,这种方式被淘汰了,替代方案(掌握)</span></span><br><span class="line"><span class="comment">            替代方案: FileReader构造方法的第二个参数</span></span><br><span class="line"><span class="comment">            E:\JavaStudy\File\gbkfile.txt</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">      InputStreamReader isr=new InputStreamReader(new FileInputStream(&quot;E:\\JavaStudy\\File\\gbkfile.txt&quot;),&quot;GBK&quot;);</span></span><br><span class="line"><span class="comment">        int b;</span></span><br><span class="line"><span class="comment">        while ((b=isr.read())!=-1)&#123;</span></span><br><span class="line"><span class="comment">            System.out.print((char) b);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        isr.close();</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//替代方案(掌握)</span></span><br><span class="line">        <span class="comment">//写出: FileWriter也是同样的用法</span></span><br><span class="line">        FileReader fr=<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;E:\\JavaStudy\\File\\gbkfile.txt&quot;</span>, Charset.forName(<span class="string">&quot;GBK&quot;</span>));</span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        <span class="keyword">while</span> ((b=fr.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>) b);</span><br><span class="line">        &#125;</span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>2: 字节流想要使用字符流中的方法</strong></p>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com_02.IOBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConvertStreamDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            利用字节流读取文件中的数据,每次读一整行,而且不能出现乱码</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            1.字节流在读取中文的时候,是会出现乱码的,但是字符流可以搞定</span></span><br><span class="line"><span class="comment">            2.字节流里面是没有读取一整行的方法的,只有字符缓冲流才能搞定</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//使用转换流 将字节流转换为字符流</span></span><br><span class="line">        InputStreamReader isr=<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\aaa\\c.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//此时的字节流在读取中文时不会出现乱码</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> isr.read();</span><br><span class="line">        System.out.println((<span class="type">char</span>) read);<span class="comment">//我</span></span><br><span class="line">        <span class="comment">//此时我们想要读取一整行的方法</span></span><br><span class="line">        BufferedReader br=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span> ((s=br.readLine())!=<span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="2-3-序列化流与反序列化流"><a href="#2-3-序列化流与反序列化流" class="headerlink" title="2.3 序列化流与反序列化流"></a>2.3 序列化流与反序列化流</h3><h4 id="2-3-1序列化流—ObjectOutputStream"><a href="#2-3-1序列化流—ObjectOutputStream" class="headerlink" title="2.3.1序列化流—ObjectOutputStream"></a>2.3.1<strong>序列化流—ObjectOutputStream</strong></h4><ul>
<li><p>字节流的一种,负责<strong>输出</strong>数据</p>
</li>
<li><p><strong>可以把Java中的对象,写到本地文件当中</strong></p>
</li>
<li><p>构造方法</p>
<table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public  ObjectOutputStream(OutputStream  out)</td>
<td>把基本流包装成高级流</td>
</tr>
</tbody></table>
</li>
<li><p>成员方法</p>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public  final  void  <strong>writeObject</strong>(Object  obj)</td>
<td>把对象序列化(写出)到文件中去</td>
</tr>
</tbody></table>
</li>
<li><p>代码示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com_02.IOBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectStreamDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        使用序列化流把对象写到本地文件中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="comment">//创建学生对象</span></span><br><span class="line">        Student s=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;zhangsan&quot;</span>,<span class="number">23</span>);</span><br><span class="line">        <span class="comment">//创建序列化流对象</span></span><br><span class="line">        ObjectOutputStream oos=<span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;src\\aaa\\e.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//写入数据</span></span><br><span class="line">        oos.writeObject(s);</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Student类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com_02.IOBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Serializable接口里面是没有抽象方法的,标记型接口</span></span><br><span class="line"><span class="comment">一旦实现了这个接口,那么就表示当前的Student类可以被序列化</span></span><br><span class="line"><span class="comment">理解:</span></span><br><span class="line"><span class="comment">    一个物品的合格证</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>序列化流小细节:</strong></p>
<ul>
<li><strong>使用序列化流将对象保存到文件时会出现 NotSerializableException异常</strong></li>
<li><strong>解决: 需要让JavaBean类实现Serializable接口</strong></li>
</ul>
</li>
</ul>
<h4 id="2-3-2反序列化流—ObjectInputStream"><a href="#2-3-2反序列化流—ObjectInputStream" class="headerlink" title="2.3.2反序列化流—ObjectInputStream"></a>2.3.2<strong>反序列化流—ObjectInputStream</strong></h4><ul>
<li><p>字节流的一种,负责<strong>输入</strong>数据</p>
</li>
<li><p>可以把序列化到本地文件中的对象,读取到程序中来</p>
</li>
<li><p>构造方法</p>
<table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public  ObjectInputStream(InputStream  out)</td>
<td>把基本流包装成高级流</td>
</tr>
</tbody></table>
</li>
<li><p>成员方法</p>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public  Object  <strong>readObject</strong>()</td>
<td>把序列化到本地文件中的对象,读取到程序中来</td>
</tr>
</tbody></table>
</li>
<li><p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com_02.IOBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectStreamDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        把序列化到本地文件中的对象,读取到程序中来</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        ObjectInputStream ois=<span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\aaa\\e.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//读取数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">        System.out.println(o);<span class="comment">//Student&#123;name = zhangsan, age = 23&#125;</span></span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-3-3-序列化流-x2F-反序列化流的细节汇总"><a href="#2-3-3-序列化流-x2F-反序列化流的细节汇总" class="headerlink" title="2.3.3 序列化流&#x2F;反序列化流的细节汇总"></a>2.3.3 序列化流&#x2F;反序列化流的细节汇总</h4><ol>
<li><p>使用<strong>序列化流将对象写到文件时,需要让Javabean类实现Serializable接口,</strong><br>否则,会出现 NotSerializableException异常</p>
</li>
<li><p>序列化流<strong>写到文件中的数据是不能修改</strong>的,一旦修改就无法再次读回来了</p>
</li>
<li><p><strong>序列化对象后,修改了Javabean类,再次反序列化,会不会有问题?</strong></p>
<p>会出问题,会抛出<strong>InvalidClassException</strong>异常</p>
<p><strong>解决方案: 给Javabean类添加(序列号、版本号)</strong></p>
</li>
<li><p><strong>如果一个对象的某个成员变量不想被序列化,又该如何实现呢?</strong></p>
<p>解决方案: <strong>给该成员变量加transient关键字修饰</strong>,该关键字标记的成员变量不参与序列化过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com_02.IOBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serial;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Serializable接口里面是没有抽象方法的,标记型接口</span></span><br><span class="line"><span class="comment">一旦实现了这个接口,那么就表示当前的Student类可以被序列化</span></span><br><span class="line"><span class="comment">理解:</span></span><br><span class="line"><span class="comment">    一个物品的合格证</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">//添加serialVersionUID之后,修改Javabean里面的内容,反序列化就不会出异常</span></span><br><span class="line">    <span class="meta">@Serial</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">6959022592033627269L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//此时address就不会被序列化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String address;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="2-3-4-练习—读写多个对象"><a href="#2-3-4-练习—读写多个对象" class="headerlink" title="2.3.4 练习—读写多个对象"></a>2.3.4 练习—读写多个对象</h4><p>Student类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com_02.IOBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serial;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Serializable接口里面是没有抽象方法的,标记型接口</span></span><br><span class="line"><span class="comment">一旦实现了这个接口,那么就表示当前的Student类可以被序列化</span></span><br><span class="line"><span class="comment">理解:</span></span><br><span class="line"><span class="comment">    一个物品的合格证</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="meta">@Serial</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">3940707122476975440L</span>;</span><br><span class="line">    <span class="comment">//添加serialVersionUID之后,修改Javabean里面的内容,反序列化就不会出异常</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> age</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> age</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> address</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> address</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddress</span><span class="params">(String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;name = &quot;</span> + name + <span class="string">&quot;, age = &quot;</span> + age + <span class="string">&quot;, address = &quot;</span> + address + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>序列化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com_02.IOBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectStreamDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        使用序列化流把对象写到本地文件中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="comment">//创建学生对象</span></span><br><span class="line">        Student s1=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;zhangsan&quot;</span>,<span class="number">23</span>,<span class="string">&quot;山东&quot;</span>);</span><br><span class="line">        Student s2=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lisi&quot;</span>,<span class="number">24</span>,<span class="string">&quot;山东&quot;</span>);</span><br><span class="line">        Student s3=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;王五&quot;</span>,<span class="number">25</span>,<span class="string">&quot;山东&quot;</span>);</span><br><span class="line">        <span class="comment">//如果此时需要序列化多个对象,那么我们就创建集合</span></span><br><span class="line">        <span class="comment">//注意此时集合的类型是Student类型的</span></span><br><span class="line">        ArrayList&lt;Student&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(s1);</span><br><span class="line">        list.add(s2);</span><br><span class="line">        list.add(s3);</span><br><span class="line">        <span class="comment">//创建序列化流对象</span></span><br><span class="line">        ObjectOutputStream oos=<span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;src\\aaa\\e.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//写入数据</span></span><br><span class="line">        <span class="comment">//直接序列化list对象</span></span><br><span class="line">        oos.writeObject(list);</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反序列化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com_02.IOBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectStreamDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        把序列化到本地文件中的对象,读取到程序中来</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        ObjectInputStream ois=<span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\aaa\\e.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//读取数据</span></span><br><span class="line">        <span class="comment">//此时读取的是Student类型的集合 而不是object类型的</span></span><br><span class="line">        <span class="comment">//所以需要进行类型转换</span></span><br><span class="line">        ArrayList&lt;Student&gt; list= (ArrayList&lt;Student&gt;) ois.readObject();</span><br><span class="line">        <span class="comment">//遍历集合 打印所有数据</span></span><br><span class="line">        <span class="keyword">for</span> (Student student : list) &#123;</span><br><span class="line">            System.out.println(student);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-打印流"><a href="#2-4-打印流" class="headerlink" title="2.4 打印流"></a>2.4 打印流</h3><ul>
<li><p>分类</p>
<ul>
<li><p><strong>PrintStream</strong></p>
</li>
<li><p><strong>PrintWriter</strong></p>
</li>
</ul>
</li>
<li><p>打印流<strong>只能写</strong>不能读</p>
</li>
<li><p>特点</p>
<ul>
<li><p><strong>1.打印流只操作文件目的地,不操作数据源</strong></p>
</li>
<li><p><strong>2.特有的写出方法可以实现,数据原样写出</strong></p>
<ul>
<li>例如 : 打印: 97 			文件中: 97</li>
</ul>
</li>
<li><p><strong>3.特有的写出方法,可以实现自动刷新,自动换行</strong></p>
<ul>
<li>打印一次数据&#x3D;写出 + 换行+ 刷新</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-4-1-字节打印流"><a href="#2-4-1-字节打印流" class="headerlink" title="2.4.1 字节打印流"></a>2.4.1 字节打印流</h4><ul>
<li><p>构造方法</p>
<table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public  PrintStream(OutputStream&#x2F;File&#x2F;String)</td>
<td>关联字节输入流&#x2F;文件&#x2F;文件路径</td>
</tr>
<tr>
<td>public  PrintStream(String  fileName, Charset  charset)</td>
<td>指定字符编码</td>
</tr>
<tr>
<td>public  PrintStream(OutputStream  out , boolean  autoFlush)</td>
<td>自动刷新</td>
</tr>
<tr>
<td>public  PrintStream(OutputStream  out , boolean  autoFlush, String  encoding)</td>
<td>指定字符编码且自动刷新</td>
</tr>
</tbody></table>
<p>注: 字节流底层没有缓冲区,开不开自动刷新都一样</p>
</li>
<li><p>成员方法</p>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public  void  write(int b)</td>
<td>常规方法:规则跟之前一样,将指定的字节写出</td>
</tr>
<tr>
<td>public  void  <strong>println</strong>(Xxx  xx)</td>
<td><strong>特有方法: 打印任意数据,自动刷新,自动换行</strong></td>
</tr>
<tr>
<td>public  void  <strong>print</strong>(Xxx  xx)</td>
<td><strong>特有方法: 打印任意数据,不换行</strong></td>
</tr>
<tr>
<td>public  void  <strong>printf</strong>(String  format, Object…  args)</td>
<td><strong>特有方法: 带有占位符的打印语句,不换行</strong></td>
</tr>
</tbody></table>
</li>
<li><p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com_02.IOBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintStreamDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException, UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        | 成员方法                                                  | 说明                                         |</span></span><br><span class="line"><span class="comment">        | public  void  write(int b)                                | 常规方法:规则跟之前一样,将指定的字节写出     |</span></span><br><span class="line"><span class="comment">        | public  void  println(Xxx  xx)                        | 特有方法: 打印任意数据,自动刷新,自动换行** |</span></span><br><span class="line"><span class="comment">        | public  void  print(Xxx  xx)                          | 特有方法: 打印任意数据,不换行**            |</span></span><br><span class="line"><span class="comment">        | public  void  printf(String  format, Object...  args) | 特有方法: 带有占位符的打印语句,不换行**    |</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//1.创建字节打印流的对象</span></span><br><span class="line">        PrintStream ps=<span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;src\\aaa\\a.txt&quot;</span>),<span class="literal">true</span>,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">//2.写出数据</span></span><br><span class="line">        ps.write(<span class="number">97</span>);<span class="comment">//写一个a</span></span><br><span class="line">        ps.println(<span class="number">97</span>);<span class="comment">//原样写出97</span></span><br><span class="line">        ps.print(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">        ps.println();</span><br><span class="line">        ps.printf(<span class="string">&quot;%s爱上了%s&quot;</span>,<span class="string">&quot;阿珍&quot;</span>,<span class="string">&quot;阿强&quot;</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        a97</span></span><br><span class="line"><span class="comment">        你好</span></span><br><span class="line"><span class="comment">        阿珍爱上了阿强</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//3.释放资源</span></span><br><span class="line">        ps.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-4-2-字符打印流"><a href="#2-4-2-字符打印流" class="headerlink" title="2.4.2 字符打印流"></a>2.4.2 字符打印流</h4><ul>
<li><p>构造方法</p>
<table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public  PrintWriter(Writer&#x2F;File&#x2F;String)</td>
<td>关联字节输入流&#x2F;文件&#x2F;文件路径</td>
</tr>
<tr>
<td>public  PrintWriter(String  fileName, Charset  charset)</td>
<td>指定字符编码</td>
</tr>
<tr>
<td>public  PrintWriter(Writer w , boolean  autoFlush)</td>
<td>自动刷新</td>
</tr>
<tr>
<td>public  PrintWriter(Writer w, boolean  autoFlush, Charset  charset)</td>
<td>指定字符编码且自动刷新</td>
</tr>
</tbody></table>
<p><strong>注: 字符流底层有缓冲区,想要自动刷新需要开启</strong></p>
</li>
<li><p>成员方法</p>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public  void  write(……)</td>
<td>常规方法:规则跟之前一样,写出字节或者字符串</td>
</tr>
<tr>
<td>public  void  <strong>println</strong>(Xxx  xx)</td>
<td><strong>特有方法: 打印任意类型的数据并且换行</strong></td>
</tr>
<tr>
<td>public  void  <strong>print</strong>(Xxx  xx)</td>
<td><strong>特有方法: 打印任意类型的数据,不换行</strong></td>
</tr>
<tr>
<td>public  void  <strong>printf</strong>(String  format, Object…  args)</td>
<td><strong>特有方法: 带有占位符的打印语句</strong></td>
</tr>
</tbody></table>
</li>
<li><p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com_02.IOBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintWriterDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        | 成员方法                                                  | 说明                                       |</span></span><br><span class="line"><span class="comment">        | public  void  write(......)                               | 常规方法:规则跟之前一样,写出字节或者字符串 |</span></span><br><span class="line"><span class="comment">        | public  void  println(Xxx  xx)                        | 特有方法: 打印任意类型的数据并且换行  |</span></span><br><span class="line"><span class="comment">        | public  void  print(Xxx  xx)                          | 特有方法: 打印任意类型的数据,不换行    |</span></span><br><span class="line"><span class="comment">        | public  void  printf(String  format, Object...  args) | 特有方法: 带有占位符的打印语句       |</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//1.创建字符打印流的对象</span></span><br><span class="line">        PrintWriter pw=<span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;src\\aaa\\a.txt&quot;</span>),<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//2.写出数据</span></span><br><span class="line">        pw.write(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">        pw.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        pw.print(<span class="number">88</span>);</span><br><span class="line">        pw.printf(<span class="string">&quot;%s爱上了%s&quot;</span>,<span class="string">&quot;阿珍&quot;</span>,<span class="string">&quot;阿强&quot;</span>);</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        你好hello</span></span><br><span class="line"><span class="comment">        88阿珍爱上了阿强</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//3.关闭资源</span></span><br><span class="line">        pw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出语句与打印流之间的关系</p>
<ul>
<li>系统中的<strong>标准输出流(System.out.println(…)) 是一种特殊的打印流,是不能关闭,在系统中是唯一的</strong></li>
<li>获取打印流的对象,<strong>此打印流在虚拟机启动的时候,由虚拟机创建,默认指向控制台</strong></li>
</ul>
</li>
</ul>
<h3 id="2-5-解压缩流-x2F-压缩流"><a href="#2-5-解压缩流-x2F-压缩流" class="headerlink" title="2.5 解压缩流&#x2F;压缩流"></a>2.5 解压缩流&#x2F;压缩流</h3><h4 id="2-5-1-解压缩流"><a href="#2-5-1-解压缩流" class="headerlink" title="2.5.1 解压缩流"></a>2.5.1 解压缩流</h4><ul>
<li><p><strong>解压本质</strong>: 把每一个ZipEntry按照层级拷贝到本地另一个文件夹中</p>
</li>
<li><p>方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>getNextEntry()</td>
<td>读取下一个Zip文件条目并将流定位到该条目数据的开始处</td>
</tr>
<tr>
<td>closeEntry()</td>
<td>关闭当前Zip条目</td>
</tr>
<tr>
<td>close()</td>
<td>关闭输入流,释放资源</td>
</tr>
</tbody></table>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com_02.IOBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.ZipEntry;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.ZipInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZipDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        解压缩流:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//压缩文件所在的路径</span></span><br><span class="line">        File src=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\JavaStudy\\File1.zip&quot;</span>);</span><br><span class="line">        <span class="comment">//解压到哪个文件夹(目标路径)</span></span><br><span class="line">        File dest=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\JavaStudy\\&quot;</span>);</span><br><span class="line">        <span class="comment">//文件解压的方法</span></span><br><span class="line">        zipStream(src,dest);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">zipStream</span><span class="params">(File src, File dest)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">//        解压本质: 把每一个ZipEntry按照层级拷贝到本地另一个文件夹中</span></span><br><span class="line">        <span class="comment">//创建解压缩流的对象</span></span><br><span class="line">        ZipInputStream zis=<span class="keyword">new</span> <span class="title class_">ZipInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(src));</span><br><span class="line">        <span class="comment">//读取压缩文件中的内容</span></span><br><span class="line">        <span class="comment">//entry表示读取到的所有文件或者文件夹</span></span><br><span class="line">        ZipEntry entry;</span><br><span class="line">        <span class="keyword">while</span> ((entry=zis.getNextEntry())!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.isDirectory())&#123;</span><br><span class="line">                <span class="comment">//如果读取到的是文件夹,需要在目的地destiny处创建一个同样的文件夹</span></span><br><span class="line">                File file=<span class="keyword">new</span> <span class="title class_">File</span>(dest,entry.toString());</span><br><span class="line">                file.mkdirs();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果是文件,需要读取解压缩包中的文件</span></span><br><span class="line">                <span class="comment">//并把它存放到目的地dest文件夹中(按照层级目录进行存放)</span></span><br><span class="line">                FileOutputStream fos=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(dest,entry.toString()));</span><br><span class="line">                <span class="type">int</span> b;</span><br><span class="line">                <span class="keyword">while</span> ((b=zis.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">//写到目的地</span></span><br><span class="line">                    fos.write(b);</span><br><span class="line">                &#125;</span><br><span class="line">                fos.close();</span><br><span class="line">                <span class="comment">//表示在压缩包的一个文件处理完毕</span></span><br><span class="line">                zis.closeEntry();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//解压缩流释放资源</span></span><br><span class="line">        zis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-5-2-压缩流"><a href="#2-5-2-压缩流" class="headerlink" title="2.5.2 压缩流"></a>2.5.2 压缩流</h4><ul>
<li><p><strong>压缩本质:</strong> 把每一个(文件&#x2F;文件夹)看成ZipEntry对象放到压缩包中</p>
</li>
<li><p>方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>putNextEntry()</td>
<td>开始写入新的Zip文件</td>
</tr>
<tr>
<td>write</td>
<td>将数据写入压缩文件中</td>
</tr>
<tr>
<td>closeEntry()</td>
<td>关闭当前Zip条目</td>
</tr>
<tr>
<td>close()</td>
<td>关闭Zip输入流,释放资源</td>
</tr>
</tbody></table>
</li>
<li><p>压缩单个文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com_02.IOBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.ZipEntry;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.ZipOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZipDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        压缩流:</span></span><br><span class="line"><span class="comment">            压缩单个文件</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//要压缩的文件路径</span></span><br><span class="line">        File src=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\JavaStudy\\File1\\a.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//压缩文件放在哪</span></span><br><span class="line">        File dest=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\JavaStudy\\File1&quot;</span>);</span><br><span class="line">        <span class="comment">//文件压缩的方法</span></span><br><span class="line">        fileZipStream(src,dest);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fileZipStream</span><span class="params">(File src, File dest)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建压缩流的对象</span></span><br><span class="line">        ZipOutputStream zos=<span class="keyword">new</span> <span class="title class_">ZipOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(dest,<span class="string">&quot;a.zip&quot;</span>)));</span><br><span class="line">        <span class="comment">//创建ZipEntry对象,用来表示压缩包里面的所有文件或文件夹</span></span><br><span class="line">        <span class="comment">//名字还是叫a.txt</span></span><br><span class="line">        <span class="type">ZipEntry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZipEntry</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//将文件写入到压缩包里</span></span><br><span class="line">        zos.putNextEntry(entry);</span><br><span class="line">        <span class="comment">//将文件里面的内容写入到文件中</span></span><br><span class="line">        FileInputStream fis=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(src);</span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        <span class="keyword">while</span> ((b=fis.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            zos.write(b);</span><br><span class="line">        &#125;</span><br><span class="line">        zos.closeEntry();</span><br><span class="line">        <span class="comment">//压缩流释放资源</span></span><br><span class="line">        zos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>压缩整个文件夹</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com_02.IOBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.ZipEntry;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.ZipOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZipDemo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        压缩流:</span></span><br><span class="line"><span class="comment">            压缩整个文件夹</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//要压缩的文件夹路径</span></span><br><span class="line">        File src=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\JavaStudy\\File1&quot;</span>);</span><br><span class="line">        <span class="comment">//压缩之后的压缩包放在哪里(压缩包的父级路径)</span></span><br><span class="line">        File destParent=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\JavaStudy&quot;</span>);</span><br><span class="line">        <span class="comment">//压缩包的路径</span></span><br><span class="line">        File dest=<span class="keyword">new</span> <span class="title class_">File</span>(destParent,src.getName()+<span class="string">&quot;.zip&quot;</span>);</span><br><span class="line">        <span class="comment">//创建压缩流对象</span></span><br><span class="line">        <span class="comment">//里面的路径应该是被压缩之后的压缩包的路径</span></span><br><span class="line">        ZipOutputStream zos=<span class="keyword">new</span> <span class="title class_">ZipOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dest));</span><br><span class="line">        <span class="comment">//获取src里面的每一个文件,变成Entry对象,放入到压缩包当中</span></span><br><span class="line">        <span class="comment">//第三个参数name表示压缩包里面的那个路径</span></span><br><span class="line">        toZip(src,zos,src.getName());</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        zos.close();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    参数一:数据源</span></span><br><span class="line"><span class="comment">    参数二:压缩流</span></span><br><span class="line"><span class="comment">    参数三:压缩包内部的路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">toZip</span><span class="params">(File src,ZipOutputStream zos,String name)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//进入文件夹</span></span><br><span class="line">        File[] files = src.listFiles();</span><br><span class="line">        <span class="comment">//遍历文件夹 得到每一个文件或者文件夹</span></span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isFile())&#123;</span><br><span class="line">                <span class="comment">//如果是文件,那么变成zipentry对象,放到压缩包里面</span></span><br><span class="line">                ZipEntry entry=<span class="keyword">new</span> <span class="title class_">ZipEntry</span>(name+<span class="string">&quot;\\&quot;</span>+file.getName());</span><br><span class="line">                <span class="comment">//形式上写入压缩包</span></span><br><span class="line">                zos.putNextEntry(entry);</span><br><span class="line">                <span class="comment">//创建对象 读取文件中的数据 把数据写入到文件中</span></span><br><span class="line">                FileInputStream fis=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">                <span class="type">int</span> b;</span><br><span class="line">                <span class="keyword">while</span> ((b=fis.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">                    zos.write(b);</span><br><span class="line">                &#125;</span><br><span class="line">                fis.close();</span><br><span class="line">                zos.closeEntry();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果是文件夹,递归</span></span><br><span class="line">                toZip(file,zos,name+<span class="string">&quot;\\&quot;</span>+file.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-6-常用工具包"><a href="#2-6-常用工具包" class="headerlink" title="2.6 常用工具包"></a>2.6 常用工具包</h3><h4 id="2-6-1-Commons-io"><a href="#2-6-1-Commons-io" class="headerlink" title="2.6.1 Commons-io"></a>2.6.1 Commons-io</h4><ul>
<li><p>Commons-io 是apache开源基金组织提供的一组<strong>有关IO操作的开源工具包</strong></p>
</li>
<li><p><strong>作用: 提高IO流的开发效率</strong></p>
</li>
<li><p>Commons-io 使用步骤</p>
<ul>
<li>在项目中创建一个文件夹: lib</li>
<li>将jar包复制粘贴到lib文件夹</li>
<li>右键点击jar包,选择Add as Library-&gt;点击OK</li>
<li>在类中导包使用</li>
</ul>
</li>
<li><p>FileUtils类</p>
<table>
<thead>
<tr>
<th>FileUtils类(文件&#x2F;文件夹相关)</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>static  void  copyFile(File  srcFile, File  destFile)</td>
<td>复制文件</td>
</tr>
<tr>
<td>static  void  copyDirectory(File  srcDir, File  destDir)</td>
<td>复制文件夹</td>
</tr>
<tr>
<td>static  void  copyDirectoryToDirectory(File  srcDir, File  destDir)</td>
<td>复制文件夹</td>
</tr>
<tr>
<td>static  void  deleteDirectory(File  directory)</td>
<td>删除文件夹</td>
</tr>
<tr>
<td>static  void   cleanDirectory(File  directory)</td>
<td>清空文件夹</td>
</tr>
<tr>
<td>static  String  readFileToString(File  file, Charset  encoding)</td>
<td>读取文件中的数据变成字符串</td>
</tr>
<tr>
<td>static  void  write(File  file, CharSequence  data, String  encoding)</td>
<td>写出数据</td>
</tr>
</tbody></table>
</li>
<li><p>IOUtils</p>
<table>
<thead>
<tr>
<th>IOUtils(流相关)</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public  static  int  copy(InputStream  input, OutputStream  output)</td>
<td>复制文件</td>
</tr>
<tr>
<td>public  static  int  copyLarge(Reader  input, Writer  output)</td>
<td>复制大文件</td>
</tr>
<tr>
<td>public  static  String  readLines(Reader  input)</td>
<td>读取数据</td>
</tr>
<tr>
<td>public  static   void  write(String  data, OutputStream  output)</td>
<td>写入数据</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="2-6-2-Hutool"><a href="#2-6-2-Hutool" class="headerlink" title="2.6.2 Hutool"></a>2.6.2 Hutool</h4></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://xinyixy.github.io">zlf</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://xinyixy.github.io/2020/11/03/Java%E5%9F%BA%E7%A1%80-IO%E6%B5%81/">https://xinyixy.github.io/2020/11/03/Java%E5%9F%BA%E7%A1%80-IO%E6%B5%81/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://xinyixy.github.io" target="_blank">LAN</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="/pluginsSrc/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="/pluginsSrc/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/11/03/Java%E5%9F%BA%E7%A1%80-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="Java基础-多线程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java基础-多线程</div></div></a></div><div class="next-post pull-right"><a href="/2020/11/03/Java%E5%9F%BA%E7%A1%80-File/" title="Java基础-File"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java基础-File</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">zlf</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xinyixy" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/1207733925@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-IO%E6%B5%81-%E5%9F%BA%E6%9C%AC%E6%B5%81"><span class="toc-number">1.</span> <span class="toc-text">1.IO流(基本流)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-IO%E6%B5%81%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 IO流介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-IO%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1.1 IO流的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2-IO%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.1.2 IO流的分类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-FileOutputStream"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 FileOutputStream</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-FileOutputStream%E5%86%99%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.2.1 FileOutputStream写数据的三种方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-FileInputStream"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 FileInputStream</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-FileInputStream%E4%B8%80%E6%AC%A1%E8%AF%BB%E5%A4%9A%E4%B8%AA%E5%AD%97%E8%8A%82"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.3.1 FileInputStream一次读多个字节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%9C%A8IO%E6%B5%81%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88%E2%80%93try%E2%80%A6catch%E2%80%A6finally-%E4%BA%86%E8%A7%A3-%E8%83%BD%E7%9C%8B%E6%87%82%E4%BB%A3%E7%A0%81%E5%8D%B3%E5%8F%AF"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 在IO流中异常处理方案–try…catch…finally(了解,能看懂代码即可)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-number">1.5.</span> <span class="toc-text">1.6 字符集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%8C%E6%8F%A1"><span class="toc-number">1.6.</span> <span class="toc-text">掌握:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%8C%E6%8F%A1-1"><span class="toc-number">1.7.</span> <span class="toc-text">掌握:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-1-%E4%B9%B1%E7%A0%81"><span class="toc-number">1.7.1.</span> <span class="toc-text">1.6.1 乱码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-number">1.8.</span> <span class="toc-text">1.7 字符流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-1-FileReader"><span class="toc-number">1.8.1.</span> <span class="toc-text">1.7.1 FileReader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-2-FileWriter"><span class="toc-number">1.8.2.</span> <span class="toc-text">1.7.2 FileWriter</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-%E7%BB%83%E4%B9%A0"><span class="toc-number">1.9.</span> <span class="toc-text">1.8  练习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-IO%E6%B5%81-%E9%AB%98%E7%BA%A7%E6%B5%81"><span class="toc-number">2.</span> <span class="toc-text">2.IO流(高级流)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 缓冲流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.1.1 字节缓冲流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.1.2 字符缓冲流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-%E7%BB%83%E4%B9%A0"><span class="toc-number">2.1.3.</span> <span class="toc-text">2.1.3 练习</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 转换流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 序列化流与反序列化流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E2%80%94ObjectOutputStream"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.3.1序列化流—ObjectOutputStream</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E2%80%94ObjectInputStream"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.3.2反序列化流—ObjectInputStream</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81-x2F-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E7%9A%84%E7%BB%86%E8%8A%82%E6%B1%87%E6%80%BB"><span class="toc-number">2.3.3.</span> <span class="toc-text">2.3.3 序列化流&#x2F;反序列化流的细节汇总</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-4-%E7%BB%83%E4%B9%A0%E2%80%94%E8%AF%BB%E5%86%99%E5%A4%9A%E4%B8%AA%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.3.4.</span> <span class="toc-text">2.3.4 练习—读写多个对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E6%89%93%E5%8D%B0%E6%B5%81"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 打印流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-%E5%AD%97%E8%8A%82%E6%89%93%E5%8D%B0%E6%B5%81"><span class="toc-number">2.4.1.</span> <span class="toc-text">2.4.1 字节打印流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-%E5%AD%97%E7%AC%A6%E6%89%93%E5%8D%B0%E6%B5%81"><span class="toc-number">2.4.2.</span> <span class="toc-text">2.4.2 字符打印流</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E8%A7%A3%E5%8E%8B%E7%BC%A9%E6%B5%81-x2F-%E5%8E%8B%E7%BC%A9%E6%B5%81"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 解压缩流&#x2F;压缩流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-1-%E8%A7%A3%E5%8E%8B%E7%BC%A9%E6%B5%81"><span class="toc-number">2.5.1.</span> <span class="toc-text">2.5.1 解压缩流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-2-%E5%8E%8B%E7%BC%A9%E6%B5%81"><span class="toc-number">2.5.2.</span> <span class="toc-text">2.5.2 压缩流</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8C%85"><span class="toc-number">2.6.</span> <span class="toc-text">2.6 常用工具包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-1-Commons-io"><span class="toc-number">2.6.1.</span> <span class="toc-text">2.6.1 Commons-io</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-2-Hutool"><span class="toc-number">2.6.2.</span> <span class="toc-text">2.6.2 Hutool</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/03/20/Vue/" title="Vue思维导图">Vue思维导图</a><time datetime="2022-03-20T04:30:29.000Z" title="发表于 2022-03-20 12:30:29">2022-03-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/03/03/Ajax/" title="Ajax思维导图">Ajax思维导图</a><time datetime="2022-03-03T02:35:29.000Z" title="发表于 2022-03-03 10:35:29">2022-03-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/02/03/jQuery/" title="JQuery思维导图">JQuery思维导图</a><time datetime="2022-02-03T03:05:29.000Z" title="发表于 2022-02-03 11:05:29">2022-02-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/07/13/Springboot%E5%9F%BA%E7%A1%80%E7%AF%87/" title="Springboot基础篇">Springboot基础篇</a><time datetime="2021-07-13T04:47:07.000Z" title="发表于 2021-07-13 12:47:07">2021-07-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/06/23/SSM-SpringMVC02/" title="SSM-SpringMVC02">SSM-SpringMVC02</a><time datetime="2021-06-23T06:03:58.000Z" title="发表于 2021-06-23 14:03:58">2021-06-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="running-time"></div><div class="copyright">&copy;2020 - 2023 By zlf</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to LAN の Tiny Home!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/pluginsSrc/@fancyapps/ui/dist/fancybox/fancybox.umd.js"></script><script src="/pluginsSrc/instant.page/instantpage.js" type="module"></script><script src="/pluginsSrc/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('/pluginsSrc/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script>setInterval(()=>{let create_time=Math.round(new Date("2020-8-21-12:14:00").getTime()/1000);let timestamp=Math.round((new Date().getTime()+8*60*60*1000)/1000);let second=timestamp-create_time;let time=new Array(0,0,0,0,0);if(second>=365*24*3600){time[0]=parseInt(second/(365*24*3600));second%=365*24*3600}if(second>=24*3600){time[1]=parseInt(second/(24*3600));second%=24*3600}if(second>=3600){time[2]=parseInt(second/3600);second%=3600}if(second>=60){time[3]=parseInt(second/60);second%=60}if(second>0){time[4]=second}currentTimeHtml='小破站已经安全运行 '+time[0]+' 年 '+time[1]+' 天 '+time[2]+' 时 '+time[3]+' 分 '+time[4]+' 秒';var elementById=document.getElementById('running-time');if(elementById){elementById.innerHTML=currentTimeHtml}},1000);</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>