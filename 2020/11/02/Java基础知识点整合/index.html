<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java基础知识点整合 | LAN</title><meta name="author" content="zlf"><meta name="copyright" content="zlf"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. String类​	String 类代表字符串，Java 程序中的所有字符串文字（例如“abc”）都被实现为此类的实例。 1.1 String类的特点String类被final修饰,所以不能被继承  字符串不可变，它们的值在创建后不能被更改 虽然 String 的值是不可变的，但是它们可以被共享 字符串效果上相当于字符数组( char[] )，但是底层原理是字节数组( byte[] )  1.">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础知识点整合">
<meta property="og:url" content="https://xinyixy.github.io/2020/11/02/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E5%90%88/index.html">
<meta property="og:site_name" content="LAN">
<meta property="og:description" content="1. String类​	String 类代表字符串，Java 程序中的所有字符串文字（例如“abc”）都被实现为此类的实例。 1.1 String类的特点String类被final修饰,所以不能被继承  字符串不可变，它们的值在创建后不能被更改 虽然 String 的值是不可变的，但是它们可以被共享 字符串效果上相当于字符数组( char[] )，但是底层原理是字节数组( byte[] )  1.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xinyixy.github.io/img/avatar.png">
<meta property="article:published_time" content="2020-11-02T04:33:18.000Z">
<meta property="article:modified_time" content="2023-06-22T23:29:13.642Z">
<meta property="article:author" content="zlf">
<meta property="article:tag" content="面向对象">
<meta property="article:tag" content="类">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xinyixy.github.io/img/avatar.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://xinyixy.github.io/2020/11/02/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E5%90%88/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/pluginsSrc/@fancyapps/ui/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: '/pluginsSrc/flickr-justified-gallery/dist/fjGallery.min.js',
      css: '/pluginsSrc/flickr-justified-gallery/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java基础知识点整合',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-23 07:29:13'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 八音盒</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 皂片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于站长</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="LAN"><span class="site-name">LAN</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 八音盒</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 皂片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于站长</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java基础知识点整合</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-11-02T04:33:18.000Z" title="发表于 2020-11-02 12:33:18">2020-11-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-22T23:29:13.642Z" title="更新于 2023-06-23 07:29:13">2023-06-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>61分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java基础知识点整合"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1-String类"><a href="#1-String类" class="headerlink" title="1. String类"></a>1. String类</h2><p>​	String 类代表字符串，Java 程序中的所有字符串文字（例如“abc”）都被实现为此类的实例。</p>
<h3 id="1-1-String类的特点"><a href="#1-1-String类的特点" class="headerlink" title="1.1 String类的特点"></a>1.1 String类的特点</h3><p>String类被final修饰,所以不能被继承</p>
<ul>
<li>字符串不可变，它们的值在创建后不能被更改</li>
<li>虽然 String 的值是不可变的，但是它们可以被共享</li>
<li>字符串效果上相当于字符数组( char[] )，但是底层原理是字节数组( byte[] )</li>
</ul>
<h3 id="1-2-String类的构造方法"><a href="#1-2-String类的构造方法" class="headerlink" title="1.2 String类的构造方法"></a>1.2 String类的构造方法</h3><ul>
<li><p>常用的构造方法</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public   String()</td>
<td>创建一个空白字符串对象，不含有任何内容</td>
</tr>
<tr>
<td>public   String(char[] chs)</td>
<td>根据字符数组的内容，来创建字符串对象</td>
</tr>
<tr>
<td>public   String(byte[] bys)</td>
<td>根据字节数组的内容，来创建字符串对象</td>
</tr>
<tr>
<td>String s &#x3D;   “abc”;</td>
<td>直接赋值的方式创建字符串对象，内容就是abc</td>
</tr>
</tbody></table>
</li>
<li><p>通过构造方法创建</p>
<p>​	通过 new 创建的字符串对象，每一次 new 都会申请一个内存空间，虽然内容相同，但是地址值不同</p>
</li>
<li><p>直接赋值方式创建</p>
<p>​	以“”方式给出的字符串，只要字符序列相同(顺序和大小写)，无论在程序代码中出现几次，JVM 都只会建立一个 String 对象，并在字符串池中维护</p>
</li>
</ul>
<h3 id="1-3-String类常用方法"><a href="#1-3-String类常用方法" class="headerlink" title="1.3 String类常用方法"></a>1.3 String类常用方法</h3><h4 id="1-3-1-equals方法"><a href="#1-3-1-equals方法" class="headerlink" title="1.3.1 equals方法"></a>1.3.1 equals方法</h4><ul>
<li><p>方法介绍</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(String s)</span>     比较两个字符串内容是否相同、区分大小写</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>区别于&#x3D;&#x3D;</strong></p>
<ul>
<li>&#x3D;&#x3D; :</li>
<li>比较基本数据类型：比较的是具体的值</li>
<li>比较引用数据类型：比较的是对象地址值</li>
<li>结论: <strong>&#x3D;&#x3D;只能用于比较基本数据类型。不能比较引用数据类型。</strong></li>
</ul>
</li>
</ul>
<h4 id="1-3-2-charAt方法"><a href="#1-3-2-charAt方法" class="headerlink" title="1.3.2 charAt方法"></a>1.3.2 charAt方法</h4><ul>
<li><p><strong>charAt()：会根据索引获取对应的字符</strong></p>
</li>
<li><pre><code class="java">//2.遍历
    for (int i = 0; i &lt; str.length(); i++) &#123;
        //i 依次表示字符串的每一个索引
        //索引的范围：0 ~  长度-1

        //根据索引获取字符串里面的每一个字符
        char c = str.charAt(i);
        System.out.println(c);
    &#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 1.3.3 substring方法</span><br><span class="line"></span><br><span class="line">- 截取字符串</span><br><span class="line"></span><br><span class="line">- 返回一个新字符串,它是此字符串的一个子字符串</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">      String phoneNumber = &quot;13112349408&quot;</span><br><span class="line">      //截取手机号码中的前三位</span><br><span class="line">      //两个参数分别是 开始索引,结束索引</span><br><span class="line">      String star = phoneNumber.substring(0, 3);</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h4 id="1-3-4-replace方法"><a href="#1-3-4-replace方法" class="headerlink" title="1.3.4 replace方法"></a>1.3.4 replace方法</h4><ul>
<li><p>替换字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//1.定义一个变量表示骂人的话</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">talk</span> <span class="operator">=</span> <span class="string">&quot;后裔你玩什么啊，TMD&quot;</span>;</span><br><span class="line"><span class="comment">//2.把这句话中的敏感词进行替换</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> talk.replace(<span class="string">&quot;TMD&quot;</span>, <span class="string">&quot;***&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-StringBuilder"><a href="#2-StringBuilder" class="headerlink" title="2. StringBuilder"></a>2. StringBuilder</h2><p>StringBuilder 可以看成是一个容器，创建之后里面的内容是可变的。</p>
<p>当我们在拼接字符串和反转字符串的时候会使用到</p>
<h3 id="2-1-基本使用"><a href="#2-1-基本使用" class="headerlink" title="2.1 基本使用"></a>2.1 基本使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBuilderDemo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建对象</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.添加元素</span></span><br><span class="line">        <span class="comment">/*sb.append(1);</span></span><br><span class="line"><span class="comment">        sb.append(2.3);</span></span><br><span class="line"><span class="comment">        sb.append(true);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//反转</span></span><br><span class="line">        sb.reverse();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> sb.length();</span><br><span class="line">        System.out.println(len);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印</span></span><br><span class="line">        <span class="comment">//普及：</span></span><br><span class="line">        <span class="comment">//因为StringBuilder是Java已经写好的类</span></span><br><span class="line">        <span class="comment">//java在底层对他做了一些特殊处理。</span></span><br><span class="line">        <span class="comment">//打印对象不是地址值而是属性值。</span></span><br><span class="line">        System.out.println(sb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-常用方法"><a href="#2-2-常用方法" class="headerlink" title="2.2 常用方法"></a>2.2 常用方法</h3><h4 id="2-1-1-toString方法"><a href="#2-1-1-toString方法" class="headerlink" title="2.1.1 toString方法"></a>2.1.1 toString方法</h4><ul>
<li>返回表示此序列中数据的字符串。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//1.创建对象</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="comment">//2.添加字符串</span></span><br><span class="line">    sb.append(<span class="string">&quot;aaa&quot;</span>).append(<span class="string">&quot;bbb&quot;</span>).append(<span class="string">&quot;ccc&quot;</span>).append(<span class="string">&quot;ddd&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(sb);<span class="comment">//aaabbbcccddd</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.再把StringBuilder变回字符串</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">    System.out.println(str);<span class="comment">//aaabbbcccddd</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-reverse方法"><a href="#2-2-2-reverse方法" class="headerlink" title="2.2.2 reverse方法"></a>2.2.2 reverse方法</h4><ul>
<li><p>字符串反转</p>
</li>
<li><p>将此字符序列替换为序列的相反顺序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.键盘录入一个字符串</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个字符串&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.next();</span><br><span class="line">  		 <span class="comment">//2.反转键盘录入的字符串</span></span><br><span class="line">   		 <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append(str).reverse().toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.比较</span></span><br><span class="line">        <span class="keyword">if</span>(str.equals(result))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前字符串是对称字符串&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前字符串不是对称字符串&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-面向对象"><a href="#3-面向对象" class="headerlink" title="3. 面向对象"></a>3. 面向对象</h2><h3 id="3-1-static关键字"><a href="#3-1-static关键字" class="headerlink" title="3.1 static关键字"></a>3.1 static关键字</h3><p>1.当 <code>static</code> 修饰成员变量或者成员方法时，该变量称为<strong>静态变量</strong>，该方法称为<strong>静态方法</strong>。该类的每个对象都<strong>共享</strong>同一个类的静态变量和静态方法。任何对象都可以更改该静态变量的值或者访问静态方法。但是不推荐这种方式去访问。因为静态变量或者静态方法直接通过类名访问即可，完全没有必要用对象去访问。</p>
<p>2.无static修饰的成员变量或者成员方法，称为<strong>实例变量，实例方法</strong>，实例变量和实例方法必须创建类的对象，然后通过对象来访问。</p>
<p>3.static修饰的成员属于类，会存储在<strong>静态区</strong>，是<strong>随着类的加载而加载的</strong>，且<strong>只加载一次，所以只有一份</strong>，节省内存。存储于一块固定的内存区域（静态区），所以，<strong>可以直接被类名调用</strong>。<strong>它优先于对象存在，所以，可以被所有对象共享</strong>。</p>
<p>4.无static修饰的成员，是属于对象，对象有多少个，他们就会出现多少份。所以必须由对象调用。</p>
<p><strong>1.静态方法只能访问静态变量和静态方法</strong></p>
<p><strong>2.非静态方法可以访问所有</strong></p>
<p><strong>3.静态方法中没有this关键字</strong></p>
<h3 id="3-2-继承"><a href="#3-2-继承" class="headerlink" title="3.2 继承"></a>3.2 继承</h3><ol>
<li>Java是<strong>单继承的</strong>，一个类只能继承一个直接父类，跟现实世界很像，但是Java中的子类是更加强大的。</li>
<li><strong>每一个类都直接或者间接的继承于Object</strong></li>
<li><strong>子类不能继承父类的构造方法。</strong></li>
<li>子类可以继承父类的私有成员（成员变量，方法），只是子类无法直接访问而已，可以通过getter&#x2F;setter方法访问父类的private成员变量</li>
</ol>
<h4 id="3-2-1-super访问父类成员变量"><a href="#3-2-1-super访问父类成员变量" class="headerlink" title="3.2.1  super访问父类成员变量"></a>3.2.1  super访问父类成员变量</h4><p>子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用<code>super</code> 关键字，修饰父类成员变量，类似于之前学过的 <code>this</code> 。</p>
<p>需要注意的是：<strong>super代表的是父类对象的引用，this代表的是当前对象的引用。</strong></p>
<p><strong>使用格式：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">super</span>.父类成员变量名</span><br></pre></td></tr></table></figure>

<p><strong>super和this</strong></p>
<ol>
<li><p>用法格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.成员变量    	--    本类的</span><br><span class="line"><span class="built_in">super</span>.成员变量    	--    父类的</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.成员方法名()  	--    本类的    </span><br><span class="line"><span class="built_in">super</span>.成员方法名()   --    父类的</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造方法格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">super</span>(...) -- 调用父类的构造方法，根据参数匹配确认</span><br><span class="line"><span class="built_in">this</span>(...) -- 调用本类的其他构造方法，根据参数匹配确认</span><br></pre></td></tr></table></figure>
</li>
<li><p>小结</p>
<ul>
<li><p><strong>子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。</strong></p>
</li>
<li><p><strong>super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。</strong></p>
</li>
<li><p><strong>super(..)和this(…)是根据参数去确定调用父类哪个构造方法的。</strong></p>
</li>
<li><p>super(..)可以调用父类构造方法初始化继承自父类的成员变量的数据。</p>
</li>
<li><p>this(..)可以调用本类中的其他构造方法。</p>
</li>
</ul>
</li>
</ol>
<h4 id="3-2-2-Override重写注解"><a href="#3-2-2-Override重写注解" class="headerlink" title="3.2.2 @Override重写注解"></a>3.2.2 @Override重写注解</h4><ul>
<li><p>@Override:注解，重写注解校验！</p>
</li>
<li><p>这个注解标记的方法，就说明这个方法必须是重写父类的方法，否则编译阶段报错。</p>
</li>
<li><p>建议重写都加上这个注解，一方面可以提高代码的可读性，一方面可以防止重写出错！</p>
</li>
</ul>
<h4 id="3-2-3-继承的特点"><a href="#3-2-3-继承的特点" class="headerlink" title="3.2.3 继承的特点"></a>3.2.3 继承的特点</h4><ol>
<li>Java只支持单继承，不支持多继承。</li>
<li>一个类可以有多个子类。</li>
<li>可以多层继承。</li>
<li>顶层父类是Object类。所有的类默认继承Object，作为父类。</li>
</ol>
<h3 id="3-3-多态"><a href="#3-3-多态" class="headerlink" title="3.3 多态"></a>3.3 多态</h3><h4 id="3-1-多态的形式"><a href="#3-1-多态的形式" class="headerlink" title="3.1 多态的形式"></a>3.1 多态的形式</h4><p><strong>多态是继封装、继承之后，面向对象的第三大特性。</strong></p>
<p><strong>多态是出现在继承或者实现关系中的</strong>。</p>
<p><strong>多态体现的格式</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">父类类型 变量名 = <span class="keyword">new</span> 子类/实现类构造器;</span><br><span class="line">变量名.方法名();</span><br></pre></td></tr></table></figure>

<p><strong>多态的前提</strong>：有继承关系，子类对象是可以赋值给父类类型的变量。例如Animal是一个动物类型，而Cat是一个猫类型。Cat继承了Animal，Cat对象也是Animal类型，自然可以赋值给父类类型的变量。</p>
<p><strong>要注意的是：</strong></p>
<ul>
<li>当一个方法的形参是一个类，我们可以传递这个类所有的子类对象。</li>
<li><strong>当一个方法的形参是一个接口，我们可以传递这个接口所有的实现类对象</strong>。</li>
<li>而且多态还可以根据传递的不同对象来调用不同类中的方法。</li>
</ul>
<h4 id="3-2-多态的定义和前提"><a href="#3-2-多态的定义和前提" class="headerlink" title="3.2 多态的定义和前提"></a>3.2 多态的定义和前提</h4><p><strong>多态</strong>： 是指同一行为，具有多个不同表现形式。</p>
<p>Cat和Dog都是动物，都是吃这一行为，但是出现的效果（表现形式）是不一样的。</p>
<p> <strong>前提【重点】</strong></p>
<ol>
<li><p>有继承或者实现关系</p>
</li>
<li><p>方法的重写【意义体现：不重写，无意义】</p>
</li>
<li><p>父类引用指向子类对象【格式体现】</p>
<blockquote>
<p>父类类型：指子类对象继承的父类类型，或者实现的父接口类型。</p>
</blockquote>
</li>
</ol>
<h4 id="3-3-多态的运行特点"><a href="#3-3-多态的运行特点" class="headerlink" title="3.3 多态的运行特点"></a>3.3 多态的运行特点</h4><p>调用成员变量时：编译看左边，运行看左边</p>
<p>调用成员方法时：编译看左边，运行看右边</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Fu</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>()；</span><br><span class="line"><span class="comment">//编译看左边的父类中有没有name这个属性，没有就报错</span></span><br><span class="line"><span class="comment">//在实际运行的时候，把父类name属性的值打印出来</span></span><br><span class="line">System.out.println(f.name);</span><br><span class="line"><span class="comment">//编译看左边的父类中有没有show这个方法，没有就报错</span></span><br><span class="line"><span class="comment">//在实际运行的时候，运行的是子类中的show方法</span></span><br><span class="line">f.show();</span><br></pre></td></tr></table></figure>

<p><strong>多态弊端: 不能调用子类独有的方法</strong></p>
<h4 id="3-4-引用类型转换"><a href="#3-4-引用类型转换" class="headerlink" title="3.4 引用类型转换"></a>3.4 引用类型转换</h4><p>为了解决多态的弊端</p>
<h5 id="3-4-1-向上转型（自动转换）"><a href="#3-4-1-向上转型（自动转换）" class="headerlink" title="3.4.1 向上转型（自动转换）"></a>3.4.1 向上转型（自动转换）</h5><ul>
<li><strong>向上转型</strong>：多态本身是子类类型向父类类型向上转换（自动转换）的过程，这个过程是默认的。<br>当父类引用指向一个子类对象时，便是向上转型。<br>使用格式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">父类类型  变量名 = <span class="keyword">new</span> 子类类型();</span><br><span class="line">如：<span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br></pre></td></tr></table></figure>

<p><strong>原因是：父类类型相对与子类来说是大范围的类型，Animal是动物类，是父类类型。Cat是猫类，是子类类型。Animal类型的范围当然很大，包含一切动物。</strong>所以子类范围小可以直接自动转型给父类类型的变量。</p>
<h5 id="3-4-2-向下转型（强制转换）"><a href="#3-4-2-向下转型（强制转换）" class="headerlink" title="3.4.2 向下转型（强制转换）"></a>3.4.2 向下转型（强制转换）</h5><ul>
<li><strong>向下转型</strong>：父类类型向子类类型向下转换的过程，这个过程是强制的。<br>一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。</li>
</ul>
<p>使用格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">子类类型 变量名 = (子类类型) 父类变量名;</span><br><span class="line">如:<span class="type">Aniaml</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">   <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span>(Cat) a;  </span><br></pre></td></tr></table></figure>

<h4 id="3-5-instanceof关键字"><a href="#3-5-instanceof关键字" class="headerlink" title="3.5 instanceof关键字"></a>3.5 instanceof关键字</h4><p>Java提供了 <code>instanceof</code> 关键字，给引用变量做类型的校验，格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">变量名 <span class="keyword">instanceof</span> 数据类型 </span><br><span class="line">如果变量属于该数据类型或者其子类类型，返回<span class="literal">true</span>。</span><br><span class="line">如果变量不属于该数据类型或者其子类类型，返回<span class="literal">false</span>。</span><br></pre></td></tr></table></figure>

<h5 id="3-5-1-instanceof新特性"><a href="#3-5-1-instanceof新特性" class="headerlink" title="3.5.1 instanceof新特性"></a>3.5.1 instanceof新特性</h5><p>JDK14的时候提出了新特性，把判断和强转合并成了一行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新特性</span></span><br><span class="line"><span class="comment">//先判断a是否为Dog类型，如果是，则强转成Dog类型，转换之后变量名为d</span></span><br><span class="line"><span class="comment">//如果不是，则不强转，结果直接是false</span></span><br><span class="line"><span class="keyword">if</span>(a <span class="keyword">instanceof</span> Dog d)&#123;</span><br><span class="line">    d.lookHome();</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Cat c)&#123;</span><br><span class="line">    c.catchMouse();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;没有这个类型，无法转换&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-权限修饰符"><a href="#3-4-权限修饰符" class="headerlink" title="3.4 权限修饰符"></a>3.4 权限修饰符</h3><p>​	在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限，我们之前已经学习过了public 和 private，接下来我们研究一下protected和默认修饰符的作用。</p>
<ul>
<li><p>public：公共的，所有地方都可以访问。</p>
</li>
<li><p>protected：本类 ，本包，其他包中的子类都可以访问。</p>
</li>
<li><p>默认（没有修饰符）：本类 ，本包可以访问。</p>
<p>注意：默认是空着不写，不是default</p>
</li>
<li><p>private：私有的，当前类可以访问。<br><code>public &gt; protected &gt; 默认 &gt; private</code></p>
</li>
</ul>
<h4 id="3-1-不同权限的访问能力"><a href="#3-1-不同权限的访问能力" class="headerlink" title="3.1 不同权限的访问能力"></a>3.1 不同权限的访问能力</h4><table>
<thead>
<tr>
<th></th>
<th>public</th>
<th>protected</th>
<th>默认</th>
<th>private</th>
</tr>
</thead>
<tbody><tr>
<td>同一类中</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>同一包中的类</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>不同包的子类</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>不同包中的无关类</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>可见，public具有最大权限。private则是最小权限。</p>
<blockquote>
<p>小贴士：不加权限修饰符，就是默认权限</p>
</blockquote>
<h3 id="3-5-final关键字"><a href="#3-5-final关键字" class="headerlink" title="3.5 final关键字"></a>3.5 final关键字</h3><p>Java提供了<code>final</code> 关键字，表示<strong>修饰的内容不可变。</strong></p>
<ul>
<li><strong>final</strong>：  不可改变，最终的含义。可以用于修饰类、方法和变量。<ul>
<li><strong>类：被修饰的类，不能被继承。</strong></li>
<li><strong>方法：被修饰的方法，不能被重写。</strong></li>
<li><strong>变量：被修饰的变量，有且仅能被赋值一次。</strong></li>
</ul>
</li>
</ul>
<h4 id="3-5-1-final修饰类"><a href="#3-5-1-final修饰类" class="headerlink" title="3.5.1 final修饰类"></a>3.5.1 final修饰类</h4><p>final修饰的类，不能被继承。</p>
<p>格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> class 类名 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查询API发现像 <code>public final class String</code> 、<code>public final class Math</code> 、<code>public final class Scanner</code> 等，很多我们学习过的类，都是被final修饰的，目的就是供我们使用，而不让我们所以改变其内容。</p>
<h4 id="3-5-2-final修饰方法"><a href="#3-5-2-final修饰方法" class="headerlink" title="3.5.2 final修饰方法"></a>3.5.2 final修饰方法</h4><p>final修饰的方法，不能被重写。<br>格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="keyword">final</span> 返回值类型 方法名(参数列表)&#123;</span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-5-3-final修饰局部变量"><a href="#3-5-3-final修饰局部变量" class="headerlink" title="3.5.3 final修饰局部变量"></a>3.5.3 final修饰局部变量</h4><p>例1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> i;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据 <code>final</code> 的定义，例1为什么通过编译呢？因为每次循环，都是一次新的变量c。这也是需要注意的地方。</p>
<h4 id="3-5-4-final修饰成员变量"><a href="#3-5-4-final修饰成员变量" class="headerlink" title="3.5.4 final修饰成员变量"></a>3.5.4 final修饰成员变量</h4><p>成员变量涉及到初始化的问题，初始化方式有显示初始化和构造方法初始化，只能选择其中一个：</p>
<ul>
<li>显示初始化(在定义成员变量的时候立马赋值)（常用）；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>被final修饰的常量名称，一般都有书写规范，所有字母都<strong>大写</strong>。</p>
<p>常量命名规范<br>1.单个单词:全部大写</p>
<p>2.多个单词:全部大写,单词之间用下划线隔开</p>
</blockquote>
<p>细节:</p>
<p>final修饰的变量是<strong>基本类型</strong>:变量存储的<strong>数据值</strong>不能发生改变</p>
<p>final修饰的变量是<strong>引用类型</strong>:变量存储的<strong>地址值</strong>不能发生改变,对象内部的可以改变</p>
<h3 id="3-6-静态代码块"><a href="#3-6-静态代码块" class="headerlink" title="3.6 静态代码块"></a>3.6 静态代码块</h3><p><strong>格式: static{ }</strong></p>
<p><strong>特点:需要通过static关键字修饰,随着类的加载而加载,并且自动触发,只执行一次</strong></p>
<p><strong>使用场景:在类加载的时候,做一些数据初始化的时候使用</strong></p>
<p>比如做斗地主游戏的时候用的牌,可以定义为静态代码块中的内容</p>
<p>例子:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ArrayList&lt;User&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//添加一些用户信息</span></span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;zhangsan&quot;</span>,<span class="string">&quot;123456&quot;</span>,<span class="string">&quot;1888888888&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-7-内部类"><a href="#3-7-内部类" class="headerlink" title="3.7 内部类"></a>3.7 内部类</h3><h4 id="3-7-1-成员内部类面试题"><a href="#3-7-1-成员内部类面试题" class="headerlink" title="3.7.1 成员内部类面试题"></a>3.7.1 成员内部类面试题</h4><p>成员内部类: 类定义在了成员位置 (类中方法外称为成员位置，无static修饰的内部类)</p>
<p>请在?地方向上相应代码,以达到输出的内容</p>
<p>创建内部类对象时，对象中有一个隐含的Outer.this记录外部类对象的地址值</p>
<p>注意：内部类访问外部类对象的格式是：<strong>外部类名.this</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Outer.<span class="type">inner</span> <span class="variable">oi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">inner</span>();</span><br><span class="line">        oi.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;	<span class="comment">// 外部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在成员位置定义一个类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">inner</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">            System.out.println(???);	<span class="comment">// 10   答案：a</span></span><br><span class="line">            System.out.println(???);	<span class="comment">// 20	答案：this.a</span></span><br><span class="line">            System.out.println(???);	<span class="comment">// 30	答案：Outer.this.a</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-7-2-匿名内部类-重点"><a href="#3-7-2-匿名内部类-重点" class="headerlink" title="3.7.2 匿名内部类(重点)"></a>3.7.2 匿名内部类(重点)</h4><p><strong>匿名内部类</strong> ：是内部类的简化写法。他是一个隐含了名字的内部类。开发中，最常用到的内部类就是匿名内部类了。</p>
<p> <strong>格式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名或者接口名() &#123;</span><br><span class="line">     重写方法;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>包含了：</p>
<ul>
<li><p>继承或者实现关系</p>
</li>
<li><p>方法重写</p>
</li>
<li><p>创建对象</p>
</li>
</ul>
<p>所以从语法上来讲，这个整体其实是匿名内部类对象</p>
<p><strong>什么时候用到匿名内部类?</strong> </p>
<p><strong>实际上，如果我们希望定义一个只要使用一次的类，就可考虑使用匿名内部类。匿名内部类的本质作用</strong></p>
<p><strong>是为了简化代码</strong>。</p>
<h5 id="匿名内部类前提和格式"><a href="#匿名内部类前提和格式" class="headerlink" title="匿名内部类前提和格式"></a>匿名内部类前提和格式</h5><p>匿名内部类必须<strong>继承一个父类</strong>或者<strong>实现一个父接口</strong>。</p>
<p><strong>匿名内部类格式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类名或者接口名()&#123;</span><br><span class="line">    <span class="comment">// 方法重写</span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 执行语句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="匿名内部类的特点"><a href="#匿名内部类的特点" class="headerlink" title="匿名内部类的特点"></a>匿名内部类的特点</h5><ol>
<li>定义一个没有名字的内部类</li>
<li>这个类实现了父类，或者父类接口</li>
<li>匿名内部类会创建这个没有名字的类的对象</li>
</ol>
<h5 id="匿名内部类的使用场景"><a href="#匿名内部类的使用场景" class="headerlink" title="匿名内部类的使用场景"></a>匿名内部类的使用场景</h5><p>通常在<strong>方法的形式参数是接口或者抽象类</strong>时，也可以将匿名内部类作为参数传递。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Swim</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo07</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 普通方式传入对象</span></span><br><span class="line">        <span class="comment">// 创建实现类对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        </span><br><span class="line">        goSwimming(s);</span><br><span class="line">        <span class="comment">// 匿名内部类使用场景:作为方法参数传递</span></span><br><span class="line">        <span class="type">Swim</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;蝶泳...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 传入匿名内部类</span></span><br><span class="line">        goSwimming(s3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 完美方案: 一步到位</span></span><br><span class="line">        goSwimming(<span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;大学生, 蛙泳...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        goSwimming(<span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;小学生, 自由泳...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个方法,模拟请一些人去游泳</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">goSwimming</span><span class="params">(Swim s)</span> &#123;</span><br><span class="line">        s.swimming();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-常见API"><a href="#4-常见API" class="headerlink" title="4.常见API"></a>4.常见API</h2><p>Math类 <strong>获取随机数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// public static double random()返回值为double的正值，[0.0,1.0)</span></span><br><span class="line">System.out.println(<span class="string">&quot;获取到的0-1之间的随机数为: &quot;</span> + Math.random());</span><br></pre></td></tr></table></figure>

<h3 id="4-1-System类常用方法"><a href="#4-1-System类常用方法" class="headerlink" title="4.1 System类常用方法"></a>4.1 System类常用方法</h3><p><strong>常见方法介绍</strong></p>
<p>我们要学习的System类中的常见方法如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">currentTimeMillis</span><span class="params">()</span>			<span class="comment">// 获取当前时间所对应的毫秒值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>				<span class="comment">// 终止当前正在运行的Java虚拟机，0表示正常退出，非零表示异常退出</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">arraycopy</span><span class="params">(Object src,  <span class="type">int</span>  srcPos, Object dest, <span class="type">int</span> destPos, <span class="type">int</span> length)</span>; <span class="comment">// 进行数值元素copy</span></span><br><span class="line"></span><br><span class="line">例:</span><br><span class="line">  <span class="comment">// 终止JVM</span></span><br><span class="line">  System.exit(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h3 id="4-2-Object类"><a href="#4-2-Object类" class="headerlink" title="4 .2 Object类"></a>4 .2 Object类</h3><h4 id="4-2-1-概述"><a href="#4-2-1-概述" class="headerlink" title="4.2.1 概述"></a>4.2.1 概述</h4><blockquote>
<p>tips：重点讲解内容</p>
</blockquote>
<p>查看API文档，我们可以看到API文档中关于Object类的定义如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="E:\JavaStudy\笔记\Java基础\day18-API（常见API，对象克隆）\笔记\assets\1576053677194.png" alt="1576053677194"> </p>
<p>Object类所在包是java.lang包。Object 是类层次结构的根，每个类都可以将 Object 作为超类。<strong>所有类都直接或者间接的继承自该类</strong>；换句话说，该类所具备的方法，其他所有类都继承了。</p>
<p>查看API文档我们可以看到，在Object类中提供了一个无参构造方法 </p>
<p>但是一般情况下我们很少去主动的创建Object类的对象，调用其对应的方法。更多的是创建Object类的某个子类对象，然后通过子类对象调用Object类中的方法。</p>
<h4 id="4-2-2-常见方法"><a href="#4-2-2-常见方法" class="headerlink" title="4.2.2 常见方法"></a>4.2.2 常见方法</h4><blockquote>
<p>tips：重点讲解内容</p>
</blockquote>
<p><font color="red" size="3"><strong>常见方法介绍</strong></font></p>
<p>我们要学习的Object类中的常见方法如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>				<span class="comment">//返回该对象的字符串表示形式(可以看做是对象的内存地址值)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>		<span class="comment">//比较两个对象地址值是否相等；true表示相同，false表示不相同</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span>    			<span class="comment">//对象克隆</span></span><br></pre></td></tr></table></figure>

<h5 id="1-toString"><a href="#1-toString" class="headerlink" title="1. toString:"></a>1. toString:</h5><p><strong>toString核心逻辑:</strong></p>
<p><strong>当我们打印一个对象的时候,底层会调用对象的toString方法,把对象变成字符串</strong></p>
<p>我们常常将”com.itheima.api.system.demo04.Student@3f3afe78”这一部分称之为<strong>对象的内存地址值</strong>。但是一般情况下获取对象的内存地址值没有太大的意义。<strong>获取对象的成员变量的字符串拼接形式才算有意义</strong>，怎么实现呢？此时<strong>我们就需要在Student类中重写Object的toString方法。</strong></p>
<p>小结：</p>
<ol>
<li>在通过输出语句输出一个对象时，默认调用的就是toString()方法</li>
<li>输出地址值一般没有意义，我们可以通过重写toString方法去输出对应的成员变量信息（快捷键：atl + insert ， 空白处 右键 -&gt; Generate -&gt; 选择toString）</li>
<li>toString方法的作用：以良好的格式，更方便的展示对象中的属性值</li>
<li>一般情况下Jdk所提供的类都会重写Object类中的toString方法</li>
</ol>
<h5 id="2-equals方法-面试题"><a href="#2-equals方法-面试题" class="headerlink" title="2. equals方法(面试题)"></a>2. equals方法(面试题)</h5><p><strong>小结：</strong></p>
<ol>
<li><strong>默认情况下equals方法比较的是对象的地址值</strong></li>
<li><strong>比较对象的地址值是没有意义的，因此一般情况下我们都会重写Object类中的equals方法</strong>,<strong>重写之后比较的就是对象内部的属性值了</strong></li>
</ol>
<h5 id="3-克隆"><a href="#3-克隆" class="headerlink" title="3. 克隆"></a>3. 克隆</h5><p>​	把A对象的属性值完全拷贝给B对象，也叫对象拷贝,对象复制</p>
<p><strong>对象克隆的分类：</strong></p>
<blockquote>
<p>深克隆和浅克隆</p>
</blockquote>
<p><strong>浅克隆：</strong></p>
<p>​	不管对象内部的属性是基本数据类型还是引用数据类型，都<strong>完全拷贝过来</strong> </p>
<p>​	基本数据类型拷贝过来的是具体的数据，引用数据类型拷贝过来的是地址值。</p>
<p>​	<strong>Object类默认的是浅克隆</strong></p>
<p><strong>深克隆：</strong></p>
<p>​	基本数据类型拷贝过来，字符串复用，引用数据类型会重新创建新的</p>
<h3 id="4-3-Objects类"><a href="#4-3-Objects类" class="headerlink" title="4.3 Objects类"></a>4.3 Objects类</h3><p>Objects类提供了一些对象常见操作的方法。<strong>比如判断对象是否相等，判断对象是否为null等等</strong>。 </p>
<p>我们可以发现Objects类中无无参构造方法，因此我们不能使用new关键字去创建Objects的对象。同时我们可以发现Objects类中所提供的方法都是静态的。因此我们可以通过类名直接去调用这些方法。</p>
<h4 id="4-3-1-常见方法"><a href="#4-3-1-常见方法" class="headerlink" title="4.3.1 常见方法"></a>4.3.1 常见方法</h4><blockquote>
<p>tips：重点讲解内容</p>
</blockquote>
<p><font color="red" size="3"><strong>常见方法介绍</strong></font></p>
<p>我们要重点学习的Objects类中的常见方法如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">toString</span><span class="params">(Object o)</span> 					<span class="comment">// 获取对象的字符串表现形式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object a, Object b)</span>			<span class="comment">// 比较两个对象是否相等</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isNull</span><span class="params">(Object obj)</span>					<span class="comment">// 判断对象是否为null</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">nonNull</span><span class="params">(Object obj)</span>					<span class="comment">// 判断对象是否不为null</span></span><br></pre></td></tr></table></figure>

<h2 id="5-正则表达式"><a href="#5-正则表达式" class="headerlink" title="5. 正则表达式"></a>5. 正则表达式</h2><p>正则表达式就是用来验证各种字符串的规则。它内部描述了一些规则，我们可以验证用户输入的字符串是否匹配这个规则。</p>
<h3 id="5-1-正则表达式-字符类"><a href="#5-1-正则表达式-字符类" class="headerlink" title="5.1 正则表达式-字符类"></a>5.1 正则表达式-字符类</h3><ul>
<li><p>“<strong>[]</strong>“: 代表<strong>某一个</strong></p>
</li>
<li><p>语法示例：</p>
</li>
</ul>
<ol>
<li>[abc]：代表a或者b，或者c字符中的一个。</li>
<li>[^abc]：代表除a,b,c以外的任何字符。</li>
<li>[a-z]：代表a-z的所有小写字符中的一个。</li>
<li>[A-Z]：代表A-Z的所有大写字符中的一个。</li>
<li>[0-9]：代表0-9之间的某一个数字字符。</li>
<li>[a-zA-Z0-9]：代表a-z或者A-Z或者0-9之间的任意一个字符。</li>
<li>[a-dm-p]：a 到 d 或 m 到 p之间的任意一个字符</li>
</ol>
<h3 id="5-2-正则表达式-逻辑运算符"><a href="#5-2-正则表达式-逻辑运算符" class="headerlink" title="5.2 正则表达式-逻辑运算符"></a>5.2 正则表达式-逻辑运算符</h3><ul>
<li>语法示例：<ol>
<li>&amp;&amp;：并且<br>注:如果写成了一个&amp;,那么此时&amp;表示就不是交集了,而是一个简简单单的&amp;符号</li>
<li>|    ：或者</li>
<li>\  ：转义字符</li>
</ol>
</li>
</ul>
<h3 id="5-3-正则表达式-预定义字符"><a href="#5-3-正则表达式-预定义字符" class="headerlink" title="5.3 正则表达式-预定义字符"></a>5.3 正则表达式-预定义字符</h3><ul>
<li>语法示例：<ol>
<li>“.” ： 匹配任何字符。</li>
<li><strong>“\d”：任何数字[0-9]的简写；</strong></li>
<li><strong>“\D”：任何非数字[^0-9]的简写；</strong></li>
<li>“\s”： 空白字符：[ \t\n\x0B\f\r] 的简写</li>
<li>“\S”： 非空白字符：[^\s] 的简写</li>
<li><strong>“\w”：单词字符：[a-zA-Z_0-9]的简写</strong></li>
<li>“\W”：非单词字符：[^\w]</li>
</ol>
</li>
</ul>
<h3 id="5-4-正则表达式-数量词"><a href="#5-4-正则表达式-数量词" class="headerlink" title="5.4 正则表达式-数量词"></a>5.4 正则表达式-数量词</h3><ul>
<li>语法示例：<ol>
<li>X? : 0次或1次</li>
<li>X* : 0次到多次</li>
<li>X+ : 1次或多次</li>
<li>X{n} : 恰好n次</li>
<li>X{n,} : 至少n次</li>
<li>X{n,m}: n到m次(n和m都是包含的)</li>
</ol>
</li>
<li>补充:</li>
<li><strong>(?i)   忽略后面字符的大小写</strong>  (?i)abc</li>
<li>a((?i)b)c  只忽略b的大小写</li>
</ul>
<h3 id="5-5-正则表达式练习1"><a href="#5-5-正则表达式练习1" class="headerlink" title="5.5 正则表达式练习1"></a>5.5 正则表达式练习1</h3><p>需求：</p>
<p>​	请编写正则表达式验证用户输入的手机号码是否满足要求。</p>
<p>​	请编写正则表达式验证用户输入的邮箱号是否满足要求。</p>
<p>​	请编写正则表达式验证用户输入的电话号码是否满足要求。</p>
<p>​	验证手机号码 13112345678 13712345667 13945679027 139456790271</p>
<p>​	验证座机电话号码 020-2324242 02122442 027-42424 0712-3242434</p>
<p>​	验证邮箱号码 <a href="mailto:&#51;&#x32;&#51;&#50;&#x33;&#50;&#51;&#64;&#x71;&#113;&#x2e;&#99;&#111;&#109;">&#51;&#x32;&#51;&#50;&#x33;&#50;&#51;&#64;&#x71;&#113;&#x2e;&#99;&#111;&#109;</a> <a href="mailto:&#122;&#x68;&#x61;&#x6e;&#103;&#x73;&#x61;&#x6e;&#64;&#x69;&#x74;&#x63;&#x61;&#x73;&#116;&#x2e;&#x63;&#x6e;&#x6e;">&#122;&#x68;&#x61;&#x6e;&#103;&#x73;&#x61;&#x6e;&#64;&#x69;&#x74;&#x63;&#x61;&#x73;&#116;&#x2e;&#x63;&#x6e;&#x6e;</a> <a href="mailto:&#100;&#108;&#101;&#105;&#x30;&#x30;&#48;&#57;&#x40;&#x31;&#x36;&#51;&#46;&#x63;&#111;&#x6d;">&#100;&#108;&#101;&#105;&#x30;&#x30;&#48;&#57;&#x40;&#x31;&#x36;&#51;&#46;&#x63;&#111;&#x6d;</a> <a href="mailto:&#100;&#108;&#101;&#105;&#48;&#48;&#48;&#x39;&#64;&#112;&#x63;&#x69;&#x2e;&#x63;&#111;&#109;&#x2e;&#99;&#110;">&#100;&#108;&#101;&#105;&#48;&#48;&#48;&#x39;&#64;&#112;&#x63;&#x69;&#x2e;&#x63;&#111;&#109;&#x2e;&#99;&#110;</a></p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.a08regexdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexDemo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//心得:</span></span><br><span class="line">        <span class="comment">//拿着一个正确的数据，从左到右依次去写。</span></span><br><span class="line">        <span class="comment">//13112345678</span></span><br><span class="line">        <span class="comment">//分成三部分:</span></span><br><span class="line">        <span class="comment">//第一部分:1 表示手机号码只能以1开头</span></span><br><span class="line">        <span class="comment">//第二部分:[3-9] 表示手机号码第二位只能是3-9之间的</span></span><br><span class="line">        <span class="comment">//第三部分:\\d&#123;9&#125; 表示任意数字可以出现9次，也只能出现9次</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">regex1</span> <span class="operator">=</span> <span class="string">&quot;1[3-9]\\d&#123;9&#125;&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;13112345678&quot;</span>.matches(regex1));<span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;13712345667&quot;</span>.matches(regex1));<span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;13945679027&quot;</span>.matches(regex1));<span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;139456790271&quot;</span>.matches(regex1));<span class="comment">//false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//座机电话号码</span></span><br><span class="line">        <span class="comment">//020-2324242 02122442 027-42424 0712-3242434</span></span><br><span class="line">        <span class="comment">//思路:</span></span><br><span class="line">        <span class="comment">//在书写座机号正则的时候需要把正确的数据分为三部分</span></span><br><span class="line">        <span class="comment">//一:区号@\\d&#123;2,3&#125;</span></span><br><span class="line">        <span class="comment">//      0:表示区号一定是以0开头的</span></span><br><span class="line">        <span class="comment">//      \\d&#123;2,3&#125;:表示区号从第二位开始可以是任意的数字，可以出现2到3次。</span></span><br><span class="line">        <span class="comment">//二:- ?表示次数，日次或一次</span></span><br><span class="line">        <span class="comment">//三:号码 号码的第一位也不能以日开头，从第二位开始可以是任意的数字，号码的总长度:5-10位</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">regex2</span> <span class="operator">=</span> <span class="string">&quot;0\\d&#123;2,3&#125;-?[1-9]\\d&#123;4,9&#125;&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;020-2324242&quot;</span>.matches(regex2));</span><br><span class="line">        System.out.println(<span class="string">&quot;02122442&quot;</span>.matches(regex2));</span><br><span class="line">        System.out.println(<span class="string">&quot;027-42424&quot;</span>.matches(regex2));</span><br><span class="line">        System.out.println(<span class="string">&quot;0712-3242434&quot;</span>.matches(regex2));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//邮箱号码</span></span><br><span class="line">        <span class="comment">//3232323@qq.com zhangsan@itcast.cnn dlei0009@163.com dlei0009@pci.com.cn</span></span><br><span class="line">        <span class="comment">//思路:</span></span><br><span class="line">        <span class="comment">//在书写邮箱号码正则的时候需要把正确的数据分为三部分</span></span><br><span class="line">        <span class="comment">//第一部分:@的左边 \\w+</span></span><br><span class="line">        <span class="comment">//      任意的字母数字下划线，至少出现一次就可以了</span></span><br><span class="line">        <span class="comment">//第二部分:@ 只能出现一次</span></span><br><span class="line">        <span class="comment">//第三部分:</span></span><br><span class="line">        <span class="comment">//      3.1         .的左边[\\w&amp;&amp;[^_]]&#123;2,6&#125;</span></span><br><span class="line">        <span class="comment">//                  任意的字母加数字，总共出现2-6次(此时不能出现下划线)</span></span><br><span class="line">        <span class="comment">//      3.2         . \\.</span></span><br><span class="line">        <span class="comment">//      3.3         大写字母，小写字母都可以，只能出现2-3次[a-zA-Z]&#123;2,3&#125;</span></span><br><span class="line">        <span class="comment">//      我们可以把3.2和3.3看成一组，这一组可以出现1次或者两次</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">regex3</span> <span class="operator">=</span> <span class="string">&quot;\\w+@[\\w&amp;&amp;[^_]]&#123;2,6&#125;(\\.[a-zA-Z]&#123;2,3&#125;)&#123;1,2&#125;&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;3232323@qq.com&quot;</span>.matches(regex3));</span><br><span class="line">        System.out.println(<span class="string">&quot;zhangsan@itcast.cnn&quot;</span>.matches(regex3));</span><br><span class="line">        System.out.println(<span class="string">&quot;dlei0009@163.com&quot;</span>.matches(regex3));</span><br><span class="line">        System.out.println(<span class="string">&quot;dlei0009@pci.com.cn&quot;</span>.matches(regex3));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//24小时的正则表达式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">regex4</span> <span class="operator">=</span> <span class="string">&quot;([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;23:11:11&quot;</span>.matches(regex4));</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">regex5</span> <span class="operator">=</span> <span class="string">&quot;([01]\\d 2[0-3])(:[0-5]\\d)&#123;2&#125;&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;23:11:11&quot;</span>.matches(regex5));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-6-正则表达式练习2"><a href="#5-6-正则表达式练习2" class="headerlink" title="5.6 正则表达式练习2"></a>5.6 正则表达式练习2</h3><p>需求<br>    请编写正则表达式验证用户名是否满足要求。要求:大小写字母，数字，下划线一共4-16位<br>    请编写正则表达式验证身份证号码是否满足要求。<br>    简单要求:<br>            18位，前17位任意数字，最后一位可以是数字可以是大写或小写的x<br>    复杂要求:<br>            按照身份证号码的格式严格要求。</p>
<p>​	身份证号码:<br>​		41080119930228457x<br>​		510801197609022309<br>​		15040119810705387X<br>​		130133197204039024<br>​		430102197606046442</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexDemo5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            正则表达式练习:</span></span><br><span class="line"><span class="comment">            需求</span></span><br><span class="line"><span class="comment">            请编写正则表达式验证用户名是否满足要求。要求:大小写字母，数字，下划线一共4-16位</span></span><br><span class="line"><span class="comment">            请编写正则表达式验证身份证号码是否满足要求。</span></span><br><span class="line"><span class="comment">            简单要求:</span></span><br><span class="line"><span class="comment">                18位，前17位任意数字，最后一位可以是数字可以是大写或小写的x</span></span><br><span class="line"><span class="comment">            复杂要求:</span></span><br><span class="line"><span class="comment">                按照身份证号码的格式严格要求。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            身份证号码:</span></span><br><span class="line"><span class="comment">            41080119930228457x</span></span><br><span class="line"><span class="comment">            510801197609022309</span></span><br><span class="line"><span class="comment">            15040119810705387X</span></span><br><span class="line"><span class="comment">            130133197204039024 I</span></span><br><span class="line"><span class="comment">            430102197606046442</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//用户名要求:大小写字母，数字，下划线一共4-16位</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">regex1</span> <span class="operator">=</span> <span class="string">&quot;\\w&#123;4,16&#125;&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;zhangsan&quot;</span>.matches(regex1));</span><br><span class="line">        System.out.println(<span class="string">&quot;lisi&quot;</span>.matches(regex1));</span><br><span class="line">        System.out.println(<span class="string">&quot;wangwu&quot;</span>.matches(regex1));</span><br><span class="line">        System.out.println(<span class="string">&quot;$123&quot;</span>.matches(regex1));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//身份证号码的简单校验:</span></span><br><span class="line">        <span class="comment">//18位，前17位任意数字，最后一位可以是数字可以是大写或小写的x</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">regex2</span> <span class="operator">=</span> <span class="string">&quot;[1-9]\\d&#123;16&#125;(\\d|x|x)&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">regex3</span> <span class="operator">=</span> <span class="string">&quot;[1-9]\\d&#123;16&#125;[\\dXx]&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">regex5</span> <span class="operator">=</span> <span class="string">&quot;[1-9]\\d&#123;16&#125;(\\d(?i)x)&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;41080119930228457x&quot;</span>.matches(regex3));</span><br><span class="line">        System.out.println(<span class="string">&quot;510801197609022309&quot;</span>.matches(regex3));</span><br><span class="line">        System.out.println(<span class="string">&quot;15040119810705387X&quot;</span>.matches(regex3));</span><br><span class="line">        System.out.println(<span class="string">&quot;130133197204039024&quot;</span>.matches(regex3));</span><br><span class="line">        System.out.println(<span class="string">&quot;430102197606046442&quot;</span>.matches(regex3));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//忽略大小写的书写方式</span></span><br><span class="line">        <span class="comment">//在匹配的时候忽略abc的大小写</span></span><br><span class="line">        <span class="comment">//String regex4 = &quot;(?i)abc&quot;;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">regex4</span> <span class="operator">=</span> <span class="string">&quot;a((?i)b)c&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;abc&quot;</span>.matches(regex4));<span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ABC&quot;</span>.matches(regex4));<span class="comment">//false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;aBc&quot;</span>.matches(regex4));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//身份证号码的严格校验</span></span><br><span class="line">        <span class="comment">//编写正则的小心得:</span></span><br><span class="line">        <span class="comment">//第一步:按照正确的数据进行拆分</span></span><br><span class="line">        <span class="comment">//第二步:找每一部分的规律，并编写正则表达式</span></span><br><span class="line">        <span class="comment">//第三步:把每一部分的正则拼接在一起，就是最终的结果</span></span><br><span class="line">        <span class="comment">//书写的时候:从左到右去书写。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//410801 1993 02 28 457x</span></span><br><span class="line">        <span class="comment">//前面6位:省份，市区，派出所等信息，第一位不能是0，后面5位是任意数字       [1-9]\\d&#123;5&#125;</span></span><br><span class="line">        <span class="comment">//年的前半段: 18 19 20                                                (18|19|20)</span></span><br><span class="line">        <span class="comment">//年的后半段: 任意数字出现两次                                           \\d&#123;2&#125;</span></span><br><span class="line">        <span class="comment">//月份: 01~ 09 10 11 12                                               (@[1-9]|1[0-2])</span></span><br><span class="line">        <span class="comment">//日期: 01~09 10~19 20~29 30 31                                       (0[1-9]|[12]\\d|3[01])</span></span><br><span class="line">        <span class="comment">//后面四位: 任意数字出现3次 最后一位可以是数字也可以是大写x或者小写x        \\d&#123;3&#125;[\\dXx]</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">regex6</span> <span class="operator">=</span> <span class="string">&quot;[1-9]\\d&#123;5&#125;(18|19|20)\\d&#123;2&#125;(@[1-9]|1[0-2])(@[1-9]|[12]\\d|3[01])\\d&#123;3&#125;[\\dxXx]&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;41080119930228457x&quot;</span>.matches(regex6));</span><br><span class="line">        System.out.println(<span class="string">&quot;510801197609022309&quot;</span>.matches(regex6));</span><br><span class="line">        System.out.println(<span class="string">&quot;15040119810705387X&quot;</span>.matches(regex6));</span><br><span class="line">        System.out.println(<span class="string">&quot;130133197204039024&quot;</span>.matches(regex6));</span><br><span class="line">        System.out.println(<span class="string">&quot;430102197606046442&quot;</span>.matches(regex6));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-7-String的split方法中使用正则表达式"><a href="#5-7-String的split方法中使用正则表达式" class="headerlink" title="5.7 String的split方法中使用正则表达式"></a>5.7 String的split方法中使用正则表达式</h3><ul>
<li><p>String类的split()方法原型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] split(String regex)</span><br><span class="line"><span class="comment">//参数regex表示正则表达式。可以将当前字符串中匹配regex正则表达式的符号作为&quot;分隔符&quot;来切割字符串。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>代码示例：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">            有一段字符串:小诗诗dqwefqwfqwfwq12312小丹丹dqwefqwfqwfwq12312小惠惠</span></span><br><span class="line"><span class="comment">            要求1:把字符串中三个姓名之间的字母替换为vs</span></span><br><span class="line"><span class="comment">            要求2:把字符串中的三个姓名切割出来*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;小诗诗dqwefqwfqwfwq12312小丹丹dqwefqwfqwfwq12312小惠惠&quot;</span>;</span><br><span class="line"><span class="comment">//细节:</span></span><br><span class="line"><span class="comment">//方法在底层跟之前一样也会创建文本解析器的对象</span></span><br><span class="line"><span class="comment">//然后从头开始去读取字符串中的内容，只要有满足的，那么就切割。</span></span><br><span class="line">String[] arr = s.split(<span class="string">&quot;[\\w&amp;&amp;[^_]]+&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-8-String类的replaceAll方法中使用正则表达式"><a href="#5-8-String类的replaceAll方法中使用正则表达式" class="headerlink" title="5.8 String类的replaceAll方法中使用正则表达式"></a>5.8 String类的replaceAll方法中使用正则表达式</h3><ul>
<li>String类的replaceAll()方法原型：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">replaceAll</span><span class="params">(String regex,String newStr)</span></span><br><span class="line"><span class="comment">//参数regex表示一个正则表达式。可以将当前字符串中匹配regex正则表达式的字符串替换为newStr。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>代码示例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">            有一段字符串:小诗诗dqwefqwfqwfwq12312小丹丹dqwefqwfqwfwq12312小惠惠</span></span><br><span class="line"><span class="comment">            要求1:把字符串中三个姓名之间的字母替换为vs</span></span><br><span class="line"><span class="comment">            要求2:把字符串中的三个姓名切割出来*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;小诗诗dqwefqwfqwfwq12312小丹丹dqwefqwfqwfwq12312小惠惠&quot;</span>;</span><br><span class="line"><span class="comment">//细节:</span></span><br><span class="line"><span class="comment">//方法在底层跟之前一样也会创建文本解析器的对象</span></span><br><span class="line"><span class="comment">//然后从头开始去读取字符串中的内容，只要有满足的，那么就用第一个参数去替换。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result1</span> <span class="operator">=</span> s.replaceAll(<span class="string">&quot;[\\w&amp;&amp;[^_]]+&quot;</span>, <span class="string">&quot;vs&quot;</span>);</span><br><span class="line">System.out.println(result1);</span><br></pre></td></tr></table></figure>

<h3 id="5-9-正则表达式-分组括号"><a href="#5-9-正则表达式-分组括号" class="headerlink" title="5.9 正则表达式-分组括号( )"></a>5.9 正则表达式-分组括号( )</h3><p>细节：如何识别组号？</p>
<p>只看左括号，不看右括号，按照左括号的顺序，从左往右，依次为第一组，第二组，第三组等等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需求1:判断一个字符串的开始字符和结束字符是否一致?只考虑一个字符</span></span><br><span class="line"><span class="comment">//举例: a123a b456b 17891 &amp;abc&amp; a123b(false)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">\\组号:表示把第X组的内容再出来用一次</span></span><br><span class="line"><span class="comment">   比如: \\1 表示把第一组的拿出来再用一次</span></span><br><span class="line"><span class="comment">         \\2 表示把第二组的拿出来再用一次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="type">String</span> <span class="variable">regex1</span> <span class="operator">=</span> <span class="string">&quot;(.).+\\1&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;a123a&quot;</span>.matches(regex1));</span><br><span class="line">System.out.println(<span class="string">&quot;b456b&quot;</span>.matches(regex1));</span><br><span class="line">System.out.println(<span class="string">&quot;17891&quot;</span>.matches(regex1));</span><br><span class="line">System.out.println(<span class="string">&quot;&amp;abc&amp;&quot;</span>.matches(regex1));</span><br><span class="line">System.out.println(<span class="string">&quot;a123b&quot;</span>.matches(regex1));</span><br><span class="line">System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//需求2:判断一个字符串的开始部分和结束部分是否一致?可以有多个字符</span></span><br><span class="line"><span class="comment">//举例: abc123abc b456b 123789123 &amp;!@abc&amp;!@ abc123abd(false)</span></span><br><span class="line"><span class="type">String</span> <span class="variable">regex2</span> <span class="operator">=</span> <span class="string">&quot;(.+).+\\1&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;abc123abc&quot;</span>.matches(regex2));</span><br><span class="line">System.out.println(<span class="string">&quot;b456b&quot;</span>.matches(regex2));</span><br><span class="line">System.out.println(<span class="string">&quot;123789123&quot;</span>.matches(regex2));</span><br><span class="line">System.out.println(<span class="string">&quot;&amp;!@abc&amp;!@&quot;</span>.matches(regex2));</span><br><span class="line">System.out.println(<span class="string">&quot;abc123abd&quot;</span>.matches(regex2));</span><br><span class="line">System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//需求3:判断一个字符串的开始部分和结束部分是否一致?开始部分内部每个字符也需要一致</span></span><br><span class="line"><span class="comment">//举例: aaa123aaa bbb456bbb 111789111 &amp;&amp;abc&amp;&amp;</span></span><br><span class="line"><span class="comment">//(.):把首字母看做一组</span></span><br><span class="line"><span class="comment">// \\2:把首字母拿出来再次使用</span></span><br><span class="line"><span class="comment">// *:作用于\\2,表示后面重复的内容出现0次或多次</span></span><br><span class="line"><span class="type">String</span> <span class="variable">regex3</span> <span class="operator">=</span> <span class="string">&quot;((.)\\2*).+\\1&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;aaa123aaa&quot;</span>.matches(regex3));</span><br><span class="line">System.out.println(<span class="string">&quot;bbb456bbb&quot;</span>.matches(regex3));</span><br><span class="line">System.out.println(<span class="string">&quot;111789111&quot;</span>.matches(regex3));</span><br><span class="line">System.out.println(<span class="string">&quot;&amp;&amp;abc&amp;&amp;&quot;</span>.matches(regex3));</span><br><span class="line">System.out.println(<span class="string">&quot;aaa123aab&quot;</span>.matches(regex3));</span><br></pre></td></tr></table></figure>

<h3 id="5-10-分组练习"><a href="#5-10-分组练习" class="headerlink" title="5.10 分组练习"></a>5.10 分组练习</h3><p>需求:</p>
<p>​    将字符串：我要学学编编编编程程程程程程。</p>
<p>​    替换为：我要学编程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;我要学学编编编编程程程程程程&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需求:把重复的内容 替换为 单个的</span></span><br><span class="line"><span class="comment">//学学                学</span></span><br><span class="line"><span class="comment">//编编编编            编</span></span><br><span class="line"><span class="comment">//程程程程程程        程</span></span><br><span class="line"><span class="comment">//  (.)表示把重复内容的第一个字符看做一组</span></span><br><span class="line"><span class="comment">//  \\1表示第一字符再次出现</span></span><br><span class="line"><span class="comment">//  + 至少一次</span></span><br><span class="line"><span class="comment">//  $1 表示把正则表达式中第一组的内容，再拿出来用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> str.replaceAll(<span class="string">&quot;(.)\\1+&quot;</span>, <span class="string">&quot;$1&quot;</span>);</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure>

<h3 id="5-11-忽略大小写的写法"><a href="#5-11-忽略大小写的写法" class="headerlink" title="5.11 忽略大小写的写法"></a>5.11 忽略大小写的写法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//(?i) ：表示忽略后面数据的大小写</span></span><br><span class="line"><span class="comment">//忽略abc的大小写</span></span><br><span class="line"><span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;(?i)abc&quot;</span>;</span><br><span class="line"><span class="comment">//a需要一模一样，忽略bc的大小写</span></span><br><span class="line"><span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;a(?i)bc&quot;</span>;</span><br><span class="line"><span class="comment">//ac需要一模一样，忽略b的大小写</span></span><br><span class="line"><span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;a((?i)b)c&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="5-12-非捕获分组"><a href="#5-12-非捕获分组" class="headerlink" title="5.12 非捕获分组"></a>5.12 非捕获分组</h3><p>非捕获分组：分组之后不需要再用本组数据，仅仅是把数据括起来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//身份证号码的简易正则表达式</span></span><br><span class="line"><span class="comment">//非捕获分组:仅仅是把数据括起来</span></span><br><span class="line"><span class="comment">//特点:不占用组号</span></span><br><span class="line"><span class="comment">//这里\\1报错原因:(?:)就是非捕获分组，此时是不占用组号的。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//(?:) (?=) (?!)都是非捕获分组//更多的使用第一个</span></span><br><span class="line"><span class="comment">//String regex1 =&quot;[1-9]\\d&#123;16&#125;(?:\\d|x|x)\\1&quot;;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">regex2</span> <span class="operator">=</span><span class="string">&quot;[1-9]\\d&#123;16&#125;(\\d Xx)\\1&quot;</span>;</span><br><span class="line"><span class="comment">//^([01]\d|2[0-3]):[0-5]\d:[@-5]\d$</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;41080119930228457x&quot;</span>.matches(regex2));</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<p><strong>捕获分组:</strong></p>
<p>后续还要继续使用本组的数据</p>
<p><strong>在正则表达式内部使用:     \\组号</strong></p>
<p><strong>在正则表达式外部使用:     $组号</strong></p>
<p><strong>非捕获分组:</strong></p>
<p>分组之后不需要再使用本组数据,仅仅只是把数据括起来</p>
<p><strong>( ? : 正则)		获取所有</strong></p>
<p><strong>( ? &#x3D; 正则)		获取前面部分</strong></p>
<p><strong>( ? ! 正则)		获取不是指定内容的前面部分</strong></p>
<h3 id="5-13-正则表达式练习"><a href="#5-13-正则表达式练习" class="headerlink" title="5.13 正则表达式练习"></a>5.13 正则表达式练习</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">手机号码:<span class="number">1</span>[<span class="number">3</span>-<span class="number">9</span>]\\d&#123;<span class="number">9</span>&#125;</span><br><span class="line">座机号码：<span class="number">0</span>\\d&#123;<span class="number">2</span>,<span class="number">3</span>&#125;-?[<span class="number">1</span>-<span class="number">9</span>]\\d&#123;<span class="number">4</span>,<span class="number">9</span>&#125;</span><br><span class="line">邮箱号码：\\w+@[\\w&amp;&amp;[^_]]&#123;<span class="number">2</span>,<span class="number">6</span>&#125;(\\.[a-zA-Z]&#123;<span class="number">2</span>,<span class="number">3</span>&#125;)&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line"><span class="number">24</span>小时：([<span class="number">01</span>]\\d|<span class="number">2</span>[<span class="number">0</span>-<span class="number">3</span>]):[<span class="number">0</span>-<span class="number">5</span>]\\d:[<span class="number">0</span>-<span class="number">5</span>]\\d</span><br><span class="line">	   ([<span class="number">01</span>]\\d|<span class="number">2</span>[<span class="number">0</span>-<span class="number">3</span>])(:[<span class="number">0</span>-<span class="number">5</span>]\\d)&#123;<span class="number">2</span>&#125;</span><br><span class="line">用户名:	\\w&#123;<span class="number">4</span>,<span class="number">16</span>&#125;</span><br><span class="line">身份证号码，简单校验：</span><br><span class="line">		[<span class="number">1</span>-<span class="number">9</span>]\\d&#123;<span class="number">16</span>&#125;(\\d|X|x)</span><br><span class="line">		[<span class="number">1</span>-<span class="number">9</span>]\\d&#123;<span class="number">16</span>&#125;[\\dXx]</span><br><span class="line">		[<span class="number">1</span>-<span class="number">9</span>]\\d&#123;<span class="number">16</span>&#125;(\\d(?i)X)</span><br><span class="line">身份证号码，严格校验：</span><br><span class="line">		[<span class="number">1</span>-<span class="number">9</span>]\\d&#123;<span class="number">5</span>&#125;(<span class="number">18</span>|<span class="number">19</span>|<span class="number">20</span>)\\d&#123;<span class="number">2</span>&#125;(<span class="number">0</span>[<span class="number">1</span>-<span class="number">9</span>]|<span class="number">1</span>[<span class="number">0</span>-<span class="number">2</span>])(<span class="number">0</span>[<span class="number">1</span>-<span class="number">9</span>|[<span class="number">12</span>])\\d|<span class="number">3</span>[<span class="number">01</span>])\\d&#123;<span class="number">3</span>&#125;[\\dXx]</span><br></pre></td></tr></table></figure>



<h2 id="6-JDK7相关时间类"><a href="#6-JDK7相关时间类" class="headerlink" title="6. JDK7相关时间类"></a>6. JDK7相关时间类</h2><h3 id="6-1-Date类"><a href="#6-1-Date类" class="headerlink" title="6.1 Date类"></a>6.1 Date类</h3><h4 id="6-1-1-Date类构造方法"><a href="#6-1-1-Date类构造方法" class="headerlink" title="6.1.1 Date类构造方法"></a>6.1.1 Date类构造方法</h4><ul>
<li>使用无参构造，可以自动设置当前系统时间的毫秒时刻；指定long类型的构造参数，可以自定义毫秒时刻。例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01Date</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建日期对象，把当前的时间</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>()); <span class="comment">// Tue Jan 16 14:37:35 CST 2020</span></span><br><span class="line">        <span class="comment">// 创建日期对象，把当前的毫秒值转成日期对象</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">0L</span>)); <span class="comment">// Thu Jan 01 08:00:00 CST 1970</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips:在使用println方法时，会自动调用Date类中的toString方法。Date类对Object类中的toString方法进行了覆盖重写，所以结果为指定格式的字符串。</p>
</blockquote>
<h4 id="6-1-2-Date常用方法"><a href="#6-1-2-Date常用方法" class="headerlink" title="6.1.2 Date常用方法"></a>6.1.2 Date常用方法</h4><p>Date类中的多数方法已经过时，常用的方法有：</p>
<ul>
<li><code>public long getTime()</code> 把日期对象转换成对应的时间毫秒值。</li>
<li><code>public void setTime(long time)</code> 把方法参数给定的毫秒值设置给日期对象</li>
</ul>
<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建日期对象</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//public long getTime():获取的是日期对象从1970年1月1日 00:00:00到现在的毫秒值</span></span><br><span class="line">        <span class="comment">//System.out.println(d.getTime());</span></span><br><span class="line">        <span class="comment">//System.out.println(d.getTime() * 1.0 / 1000 / 60 / 60 / 24 / 365 + &quot;年&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//public void setTime(long time):设置时间，给的是毫秒值</span></span><br><span class="line">        <span class="comment">//long time = 1000*60*60;</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        d.setTime(time);</span><br><span class="line"></span><br><span class="line">        System.out.println(d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小结：Date表示特定的时间瞬间，我们可以使用Date对象对时间进行操作。</p>
</blockquote>
<h3 id="6-2-SimpleDateFormat类-日期-x2F-时间格式化"><a href="#6-2-SimpleDateFormat类-日期-x2F-时间格式化" class="headerlink" title="6.2 SimpleDateFormat类(日期&#x2F;时间格式化)"></a>6.2 SimpleDateFormat类(日期&#x2F;时间格式化)</h3><p>可以在Date对象与String对象之间进行来回转换。</p>
<ul>
<li><strong>格式化</strong>：按照指定的格式，把Date对象转换为String对象。</li>
<li><strong>解析</strong>：按照指定的格式，把String对象转换为Date对象。</li>
</ul>
<h4 id="6-2-1-构造方法"><a href="#6-2-1-构造方法" class="headerlink" title="6.2.1 构造方法"></a>6.2.1 构造方法</h4><p>由于DateFormat为抽象类，不能直接使用，所以需要常用的子类<code>java.text.SimpleDateFormat</code>。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为：</p>
<ul>
<li><code>public SimpleDateFormat(String pattern)</code>：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。参数pattern是一个字符串，代表日期时间的自定义格式。</li>
<li>例如:<ul>
<li>SimpleDateFormat sdf &#x3D; new SimpleDateFormat(“<strong>yyyy-MM-dd HH:mm:ss</strong>“);</li>
</ul>
</li>
</ul>
<h4 id="6-2-2-格式规则"><a href="#6-2-2-格式规则" class="headerlink" title="6.2.2 格式规则"></a>6.2.2 格式规则</h4><p>常用的格式规则为：</p>
<table>
<thead>
<tr>
<th>标识字母（区分大小写）</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>y                             (year)</td>
<td>年</td>
</tr>
<tr>
<td>M                         (Month)</td>
<td>月</td>
</tr>
<tr>
<td>d                            (day)</td>
<td>日</td>
</tr>
<tr>
<td>H                          (Hour)</td>
<td>时</td>
</tr>
<tr>
<td>m                        (minute)</td>
<td>分</td>
</tr>
<tr>
<td>s                         (second)</td>
<td>秒</td>
</tr>
</tbody></table>
<blockquote>
<p>备注：更详细的格式规则，可以参考SimpleDateFormat类的API文档。</p>
</blockquote>
<h4 id="6-2-3-常用方法"><a href="#6-2-3-常用方法" class="headerlink" title="6.2.3 常用方法"></a>6.2.3 常用方法</h4><p>DateFormat类的常用方法有：</p>
<ul>
<li><p><code>public String format(Date date)</code>：将Date对象**(format)格式化**为字符串。</p>
</li>
<li><p><code>public Date parse(String source)</code>：将字符串**(parse)解析**为Date对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.a01jdk7datedemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A03_SimpleDateFormatDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            public simpleDateFormat() 默认格式</span></span><br><span class="line"><span class="comment">            public simpleDateFormat(String pattern) 指定格式</span></span><br><span class="line"><span class="comment">            public final string format(Date date) 格式化(日期对象 -&gt;字符串)</span></span><br><span class="line"><span class="comment">            public Date parse(string source) 解析(字符串 -&gt;日期对象)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.定义一个字符串表示时间</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;2023-11-11 11:11:11&quot;</span>;</span><br><span class="line">        <span class="comment">//2.利用空参构造创建simpleDateFormat对象</span></span><br><span class="line">        <span class="comment">// 细节:</span></span><br><span class="line">        <span class="comment">//创建对象的格式要跟字符串的格式完全一致</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> sdf.parse(str);</span><br><span class="line">        <span class="comment">//3.打印结果</span></span><br><span class="line">        System.out.println(date.getTime());<span class="comment">//1699672271000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.利用空参构造创建simpleDateFormat对象，默认格式</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">0L</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> sdf1.format(d1);</span><br><span class="line">        System.out.println(str1);<span class="comment">//1970/1/1 上午8:00</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.利用带参构造创建simpleDateFormat对象，指定格式</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> sdf2.format(d1);</span><br><span class="line">        System.out.println(str2);<span class="comment">//1970年01月01日 08:00:00</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//课堂练习:yyyy年MM月dd日 时:分:秒 星期</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>小结：DateFormat可以将Date对象和字符串相互转换。</p>
</blockquote>
<h3 id="6-3-Calendar类-日历类"><a href="#6-3-Calendar类-日历类" class="headerlink" title="6.3 Calendar类(日历类)"></a>6.3 Calendar类(日历类)</h3><h4 id="6-3-1-概述"><a href="#6-3-1-概述" class="headerlink" title="6.3.1 概述"></a>6.3.1 概述</h4><ul>
<li>它是一个抽象类，不能创建对象</li>
<li>通过Calendar的静态方法getInstance()方法获取对象</li>
</ul>
<h4 id="6-3-2-常用方法"><a href="#6-3-2-常用方法" class="headerlink" title="6.3.2 常用方法"></a>6.3.2 常用方法</h4><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static Calendar getInstance()</td>
<td>获取一个它的子类GregorianCalendar对象。</td>
</tr>
<tr>
<td>public int get(int field)</td>
<td>获取某个字段的值。field参数表示获取哪个字段的值，<br />可以使用Calender中定义的常量来表示：<br />Calendar.YEAR : 年<br />Calendar.MONTH ：月<br />Calendar.DAY_OF_MONTH：月中的日期<br />Calendar.HOUR：小时<br />Calendar.MINUTE：分钟<br />Calendar.SECOND：秒<br />Calendar.DAY_OF_WEEK：星期</td>
</tr>
<tr>
<td>public void set(int field,int value)</td>
<td>设置某个字段的值</td>
</tr>
<tr>
<td>public void add(int field,int amount)</td>
<td>为某个字段增加&#x2F;减少指定的值</td>
</tr>
</tbody></table>
<h4 id="6-3-3-get方法示例"><a href="#6-3-3-get方法示例" class="headerlink" title="6.3.3 get方法示例"></a>6.3.3 get方法示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.获取一个GregorianCalendar对象</span></span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">instance</span> <span class="operator">=</span> Calendar.getInstance();<span class="comment">//获取子类对象</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.打印子类对象</span></span><br><span class="line">        System.out.println(instance);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.获取属性</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> instance.get(Calendar.YEAR);</span><br><span class="line">        <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> instance.get(Calendar.MONTH) + <span class="number">1</span>;<span class="comment">//Calendar的月份值是0-11</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> instance.get(Calendar.DAY_OF_MONTH);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">hour</span> <span class="operator">=</span> instance.get(Calendar.HOUR);</span><br><span class="line">        <span class="type">int</span> <span class="variable">minute</span> <span class="operator">=</span> instance.get(Calendar.MINUTE);</span><br><span class="line">        <span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> instance.get(Calendar.SECOND);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">week</span> <span class="operator">=</span> instance.get(Calendar.DAY_OF_WEEK);<span class="comment">//返回值范围：1--7，分别表示：&quot;星期日&quot;,&quot;星期一&quot;,&quot;星期二&quot;,...,&quot;星期六&quot;</span></span><br><span class="line"></span><br><span class="line">        System.out.println(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + day + <span class="string">&quot;日&quot;</span> + </span><br><span class="line">                           	hour + <span class="string">&quot;:&quot;</span> + minute + <span class="string">&quot;:&quot;</span> + second);</span><br><span class="line">        System.out.println(getWeek(week));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查表法，查询星期几</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getWeek</span><span class="params">(<span class="type">int</span> w)</span> &#123;<span class="comment">//w = 1 --- 7</span></span><br><span class="line">        <span class="comment">//做一个表(数组)</span></span><br><span class="line">        String[] weekArray = &#123;<span class="string">&quot;星期日&quot;</span>, <span class="string">&quot;星期一&quot;</span>, <span class="string">&quot;星期二&quot;</span>, <span class="string">&quot;星期三&quot;</span>, <span class="string">&quot;星期四&quot;</span>, <span class="string">&quot;星期五&quot;</span>, <span class="string">&quot;星期六&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//            索引      [0]      [1]       [2]      [3]       [4]      [5]      [6]</span></span><br><span class="line">        <span class="comment">//查表</span></span><br><span class="line">        <span class="keyword">return</span> weekArray[w - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="6-3-4-set方法示例："><a href="#6-3-4-set方法示例：" class="headerlink" title="6.3.4 set方法示例："></a>6.3.4 set方法示例：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//设置属性——set(int field,int value):</span></span><br><span class="line">		<span class="type">Calendar</span> <span class="variable">c1</span> <span class="operator">=</span> Calendar.getInstance();<span class="comment">//获取当前日期</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//计算班长出生那天是星期几(假如班长出生日期为：1998年3月18日)</span></span><br><span class="line">		c1.set(Calendar.YEAR, <span class="number">1998</span>);</span><br><span class="line">		c1.set(Calendar.MONTH, <span class="number">3</span> - <span class="number">1</span>);<span class="comment">//转换为Calendar内部的月份值</span></span><br><span class="line">		c1.set(Calendar.DAY_OF_MONTH, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> c1.get(Calendar.DAY_OF_WEEK);</span><br><span class="line">		System.out.println(<span class="string">&quot;班长出生那天是：&quot;</span> + getWeek(w));</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查表法，查询星期几</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getWeek</span><span class="params">(<span class="type">int</span> w)</span> &#123;<span class="comment">//w = 1 --- 7</span></span><br><span class="line">        <span class="comment">//做一个表(数组)</span></span><br><span class="line">        String[] weekArray = &#123;<span class="string">&quot;星期日&quot;</span>, <span class="string">&quot;星期一&quot;</span>, <span class="string">&quot;星期二&quot;</span>, <span class="string">&quot;星期三&quot;</span>, <span class="string">&quot;星期四&quot;</span>, <span class="string">&quot;星期五&quot;</span>, <span class="string">&quot;星期六&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//            索引      [0]      [1]       [2]      [3]       [4]      [5]      [6]</span></span><br><span class="line">        <span class="comment">//查表</span></span><br><span class="line">        <span class="keyword">return</span> weekArray[w - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="6-3-5-add方法示例："><a href="#6-3-5-add方法示例：" class="headerlink" title="6.3.5 add方法示例："></a>6.3.5 add方法示例：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//计算200天以后是哪年哪月哪日，星期几？</span></span><br><span class="line">		<span class="type">Calendar</span> <span class="variable">c2</span> <span class="operator">=</span> Calendar.getInstance();<span class="comment">//获取当前日期</span></span><br><span class="line">        c2.add(Calendar.DAY_OF_MONTH, <span class="number">200</span>);<span class="comment">//日期加200</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> c2.get(Calendar.YEAR);</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> c2.get(Calendar.MONTH) + <span class="number">1</span>;<span class="comment">//转换为实际的月份</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> c2.get(Calendar.DAY_OF_MONTH);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">wk</span> <span class="operator">=</span> c2.get(Calendar.DAY_OF_WEEK);</span><br><span class="line">        System.out.println(<span class="string">&quot;200天后是：&quot;</span> + y + <span class="string">&quot;年&quot;</span> + m + <span class="string">&quot;月&quot;</span> + d + <span class="string">&quot;日&quot;</span> + getWeek(wk));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查表法，查询星期几</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getWeek</span><span class="params">(<span class="type">int</span> w)</span> &#123;<span class="comment">//w = 1 --- 7</span></span><br><span class="line">        <span class="comment">//做一个表(数组)</span></span><br><span class="line">        String[] weekArray = &#123;<span class="string">&quot;星期日&quot;</span>, <span class="string">&quot;星期一&quot;</span>, <span class="string">&quot;星期二&quot;</span>, <span class="string">&quot;星期三&quot;</span>, <span class="string">&quot;星期四&quot;</span>, <span class="string">&quot;星期五&quot;</span>, <span class="string">&quot;星期六&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//            索引      [0]      [1]       [2]      [3]       [4]      [5]      [6]</span></span><br><span class="line">        <span class="comment">//查表</span></span><br><span class="line">        <span class="keyword">return</span> weekArray[w - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-JDK8相关时间类"><a href="#7-JDK8相关时间类" class="headerlink" title="7. JDK8相关时间类"></a>7. JDK8相关时间类</h2><p><strong>细节:</strong></p>
<p><strong>JDK8新增的时间对象都是不可变的</strong></p>
<p><strong>如果我们修改了,减少了,增加了时间</strong></p>
<p><strong>那么调用者是不会发生改变的,只会产生一个新的时间</strong></p>
<h3 id="7-1-Date类-ZoneId、Instant、ZoneDateTime"><a href="#7-1-Date类-ZoneId、Instant、ZoneDateTime" class="headerlink" title="7.1 Date类(ZoneId、Instant、ZoneDateTime)"></a>7.1 Date类(ZoneId、Instant、ZoneDateTime)</h3><h4 id="7-1-1-ZoneId时区"><a href="#7-1-1-ZoneId时区" class="headerlink" title="7.1.1 ZoneId时区"></a>7.1.1 ZoneId时区</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        static Set&lt;string&gt; getAvailableZoneIds() 获取Java中支持的所有时区</span></span><br><span class="line"><span class="comment">        static ZoneId systemDefault() 获取系统默认时区</span></span><br><span class="line"><span class="comment">        static Zoneld of(string zoneld) 获取一个指定时区</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.获取所有的时区名称</span></span><br><span class="line">Set&lt;String&gt; zoneIds = ZoneId.getAvailableZoneIds();</span><br><span class="line">System.out.println(zoneIds.size());<span class="comment">//600</span></span><br><span class="line">System.out.println(zoneIds);<span class="comment">// Asia/Shanghai</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.获取当前系统的默认时区</span></span><br><span class="line"><span class="type">ZoneId</span> <span class="variable">zoneId</span> <span class="operator">=</span> ZoneId.systemDefault();</span><br><span class="line">System.out.println(zoneId);<span class="comment">//Asia/Shanghai</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.获取指定的时区</span></span><br><span class="line"><span class="type">ZoneId</span> <span class="variable">zoneId1</span> <span class="operator">=</span> ZoneId.of(<span class="string">&quot;Asia/Pontianak&quot;</span>);</span><br><span class="line">System.out.println(zoneId1);<span class="comment">//Asia/Pontianak</span></span><br></pre></td></tr></table></figure>



<h4 id="7-1-2-Instant-时间戳"><a href="#7-1-2-Instant-时间戳" class="headerlink" title="7.1.2  Instant 时间戳"></a>7.1.2  Instant 时间戳</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">            static Instant now() 获取当前时间的Instant对象(标准时间)</span></span><br><span class="line"><span class="comment">            static Instant ofXxxx(long epochMilli) 根据(秒/毫秒/纳秒)获取Instant对象</span></span><br><span class="line"><span class="comment">            ZonedDateTime atZone(ZoneIdzone) 指定时区</span></span><br><span class="line"><span class="comment">            boolean isxxx(Instant otherInstant) 判断系列的方法</span></span><br><span class="line"><span class="comment">            Instant minusXxx(long millisToSubtract) 减少时间系列的方法</span></span><br><span class="line"><span class="comment">            Instant plusXxx(long millisToSubtract) 增加时间系列的方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//1.获取当前时间的Instant对象(标准时间)</span></span><br><span class="line"><span class="type">Instant</span> <span class="variable">now</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">System.out.println(now);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.根据(秒/毫秒/纳秒)获取Instant对象</span></span><br><span class="line"><span class="type">Instant</span> <span class="variable">instant1</span> <span class="operator">=</span> Instant.ofEpochMilli(<span class="number">0L</span>);</span><br><span class="line">System.out.println(instant1);<span class="comment">//1970-01-01T00:00:00z</span></span><br><span class="line"></span><br><span class="line"><span class="type">Instant</span> <span class="variable">instant2</span> <span class="operator">=</span> Instant.ofEpochSecond(<span class="number">1L</span>);</span><br><span class="line">System.out.println(instant2);<span class="comment">//1970-01-01T00:00:01Z</span></span><br><span class="line"></span><br><span class="line"><span class="type">Instant</span> <span class="variable">instant3</span> <span class="operator">=</span> Instant.ofEpochSecond(<span class="number">1L</span>, <span class="number">1000000000L</span>);</span><br><span class="line">System.out.println(instant3);<span class="comment">//1970-01-01T00:00:027</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 指定时区</span></span><br><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">time</span> <span class="operator">=</span> Instant.now().atZone(ZoneId.of(<span class="string">&quot;Asia/Shanghai&quot;</span>));</span><br><span class="line">System.out.println(time);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.isXxx 判断</span></span><br><span class="line">Instant instant4=Instant.ofEpochMilli(<span class="number">0L</span>);</span><br><span class="line"><span class="type">Instant</span> <span class="variable">instant5</span> <span class="operator">=</span>Instant.ofEpochMilli(<span class="number">1000L</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.用于时间的判断</span></span><br><span class="line"><span class="comment">//isBefore:判断调用者代表的时间是否在参数表示时间的前面</span></span><br><span class="line"><span class="type">boolean</span> result1=instant4.isBefore(instant5);</span><br><span class="line">System.out.println(result1);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//isAfter:判断调用者代表的时间是否在参数表示时间的后面</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">result2</span> <span class="operator">=</span> instant4.isAfter(instant5);</span><br><span class="line">System.out.println(result2);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//6.Instant minusXxx(long millisToSubtract) 减少时间系列的方法</span></span><br><span class="line"><span class="type">Instant</span> <span class="variable">instant6</span> <span class="operator">=</span>Instant.ofEpochMilli(<span class="number">3000L</span>);</span><br><span class="line">System.out.println(instant6);<span class="comment">//1970-01-01T00:00:03Z</span></span><br><span class="line"></span><br><span class="line"><span class="type">Instant</span> <span class="variable">instant7</span> <span class="operator">=</span>instant6.minusSeconds(<span class="number">1</span>);</span><br><span class="line">System.out.println(instant7);<span class="comment">//1970-01-01T00:00:02Z</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="7-1-3-ZoneDateTime-带时区的时间"><a href="#7-1-3-ZoneDateTime-带时区的时间" class="headerlink" title="7.1.3 ZoneDateTime  带时区的时间"></a>7.1.3 ZoneDateTime  带时区的时间</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">            static ZonedDateTime now() 获取当前时间的ZonedDateTime对象</span></span><br><span class="line"><span class="comment">            static ZonedDateTime ofXxxx(。。。) 获取指定时间的ZonedDateTime对象</span></span><br><span class="line"><span class="comment">            ZonedDateTime withXxx(时间) 修改时间系列的方法</span></span><br><span class="line"><span class="comment">            ZonedDateTime minusXxx(时间) 减少时间系列的方法</span></span><br><span class="line"><span class="comment">            ZonedDateTime plusXxx(时间) 增加时间系列的方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//1.获取当前时间对象(带时区)</span></span><br><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">now</span> <span class="operator">=</span> ZonedDateTime.now();</span><br><span class="line">System.out.println(now);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.获取指定的时间对象(带时区)        年  月  日  时  分  秒  纳秒  方式指定</span></span><br><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">time1</span> <span class="operator">=</span> ZonedDateTime.of(<span class="number">2023</span>, <span class="number">10</span>, <span class="number">1</span>,</span><br><span class="line">                                       <span class="number">11</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">0</span>, ZoneId.of(<span class="string">&quot;Asia/Shanghai&quot;</span>));</span><br><span class="line">System.out.println(time1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Instant + 时区的方式指定获取时间对象</span></span><br><span class="line"><span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> Instant.ofEpochMilli(<span class="number">0L</span>);</span><br><span class="line"><span class="type">ZoneId</span> <span class="variable">zoneId</span> <span class="operator">=</span> ZoneId.of(<span class="string">&quot;Asia/Shanghai&quot;</span>);</span><br><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">time2</span> <span class="operator">=</span> ZonedDateTime.ofInstant(instant, zoneId);</span><br><span class="line">System.out.println(time2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.withXxx 修改时间系列的方法</span></span><br><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">time3</span> <span class="operator">=</span> time2.withYear(<span class="number">2000</span>);</span><br><span class="line">System.out.println(time3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 减少时间</span></span><br><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">time4</span> <span class="operator">=</span> time3.minusYears(<span class="number">1</span>);</span><br><span class="line">System.out.println(time4);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.增加时间</span></span><br><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">time5</span> <span class="operator">=</span> time4.plusYears(<span class="number">1</span>);</span><br><span class="line">System.out.println(time5);</span><br></pre></td></tr></table></figure>



<h3 id="7-2-日期格式化类-DateTimeFormatter"><a href="#7-2-日期格式化类-DateTimeFormatter" class="headerlink" title="7.2 日期格式化类(DateTimeFormatter)"></a>7.2 日期格式化类(DateTimeFormatter)</h3><h4 id="7-2-1-DateTimeFormatter-用于时间的格式化和解析"><a href="#7-2-1-DateTimeFormatter-用于时间的格式化和解析" class="headerlink" title="7.2.1 DateTimeFormatter   用于时间的格式化和解析"></a>7.2.1 DateTimeFormatter   用于时间的格式化和解析</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">            static DateTimeFormatter ofPattern(格式) 获取格式对象</span></span><br><span class="line"><span class="comment">            String format(时间对象) 按照指定方式格式化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//获取时间对象</span></span><br><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">time</span> <span class="operator">=</span> Instant.now().atZone(ZoneId.of(<span class="string">&quot;Asia/Shanghai&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析/格式化器</span></span><br><span class="line">DateTimeFormatter dtf1=DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm;ss EE a&quot;</span>);</span><br><span class="line"><span class="comment">// 格式化</span></span><br><span class="line">System.out.println(dtf1.format(time));</span><br></pre></td></tr></table></figure>



<h3 id="7-3-日历类-LocalDate、LocalTime、LocalDateTime"><a href="#7-3-日历类-LocalDate、LocalTime、LocalDateTime" class="headerlink" title="7.3 日历类(LocalDate、LocalTime、LocalDateTime)"></a>7.3 日历类(LocalDate、LocalTime、LocalDateTime)</h3><h4 id="7-3-1-LocalDate-年、月、日"><a href="#7-3-1-LocalDate-年、月、日" class="headerlink" title="7.3.1 LocalDate  年、月、日"></a>7.3.1 LocalDate  年、月、日</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.获取当前时间的日历对象(包含 年月日)</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">nowDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line"><span class="comment">//System.out.println(&quot;今天的日期:&quot; + nowDate);</span></span><br><span class="line"><span class="comment">//2.获取指定的时间的日历对象</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">ldDate</span> <span class="operator">=</span> LocalDate.of(<span class="number">2023</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;指定日期:&quot;</span> + ldDate);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;=============================&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.get系列方法获取日历中的每一个属性值//获取年</span></span><br><span class="line"><span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> ldDate.getYear();</span><br><span class="line">System.out.println(<span class="string">&quot;year: &quot;</span> + year);</span><br><span class="line"><span class="comment">//获取月//方式一:</span></span><br><span class="line"><span class="type">Month</span> <span class="variable">m</span> <span class="operator">=</span> ldDate.getMonth();</span><br><span class="line">System.out.println(m);</span><br><span class="line">System.out.println(m.getValue());</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二:</span></span><br><span class="line"><span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> ldDate.getMonthValue();</span><br><span class="line">System.out.println(<span class="string">&quot;month: &quot;</span> + month);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取日</span></span><br><span class="line"><span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> ldDate.getDayOfMonth();</span><br><span class="line">System.out.println(<span class="string">&quot;day:&quot;</span> + day);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取一年的第几天</span></span><br><span class="line"><span class="type">int</span> <span class="variable">dayofYear</span> <span class="operator">=</span> ldDate.getDayOfYear();</span><br><span class="line">System.out.println(<span class="string">&quot;dayOfYear:&quot;</span> + dayofYear);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取星期</span></span><br><span class="line"><span class="type">DayOfWeek</span> <span class="variable">dayOfWeek</span> <span class="operator">=</span> ldDate.getDayOfWeek();</span><br><span class="line">System.out.println(dayOfWeek);</span><br><span class="line">System.out.println(dayOfWeek.getValue());</span><br><span class="line"></span><br><span class="line"><span class="comment">//is开头的方法表示判断</span></span><br><span class="line">System.out.println(ldDate.isBefore(ldDate));</span><br><span class="line">System.out.println(ldDate.isAfter(ldDate));</span><br><span class="line"></span><br><span class="line"><span class="comment">//with开头的方法表示修改，只能修改年月日</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">withLocalDate</span> <span class="operator">=</span> ldDate.withYear(<span class="number">2000</span>);</span><br><span class="line">System.out.println(withLocalDate);</span><br><span class="line"></span><br><span class="line"><span class="comment">//minus开头的方法表示减少，只能减少年月日</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">minusLocalDate</span> <span class="operator">=</span> ldDate.minusYears(<span class="number">1</span>);</span><br><span class="line">System.out.println(minusLocalDate);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//plus开头的方法表示增加，只能增加年月日</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">plusLocalDate</span> <span class="operator">=</span> ldDate.plusDays(<span class="number">1</span>);</span><br><span class="line">System.out.println(plusLocalDate);</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------</span></span><br><span class="line"><span class="comment">// 判断今天是否是你的生日</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">birDate</span> <span class="operator">=</span> LocalDate.of(<span class="number">2000</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">nowDate1</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line"></span><br><span class="line"><span class="type">MonthDay</span> <span class="variable">birMd</span> <span class="operator">=</span> MonthDay.of(birDate.getMonthValue(), birDate.getDayOfMonth());</span><br><span class="line"><span class="type">MonthDay</span> <span class="variable">nowMd</span> <span class="operator">=</span> MonthDay.from(nowDate1);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;今天是你的生日吗? &quot;</span> + birMd.equals(nowMd));<span class="comment">//今天是你的生日吗?</span></span><br></pre></td></tr></table></figure>



<h4 id="7-3-2-LocalTime-时、分、秒"><a href="#7-3-2-LocalTime-时、分、秒" class="headerlink" title="7.3.2 LocalTime  时、分、秒"></a>7.3.2 LocalTime  时、分、秒</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取本地时间的日历对象。(包含 时分秒)</span></span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">nowTime</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">System.out.println(<span class="string">&quot;今天的时间:&quot;</span> + nowTime);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">hour</span> <span class="operator">=</span> nowTime.getHour();<span class="comment">//时</span></span><br><span class="line">System.out.println(<span class="string">&quot;hour: &quot;</span> + hour);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">minute</span> <span class="operator">=</span> nowTime.getMinute();<span class="comment">//分</span></span><br><span class="line">System.out.println(<span class="string">&quot;minute: &quot;</span> + minute);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> nowTime.getSecond();<span class="comment">//秒</span></span><br><span class="line">System.out.println(<span class="string">&quot;second:&quot;</span> + second);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">nano</span> <span class="operator">=</span> nowTime.getNano();<span class="comment">//纳秒</span></span><br><span class="line">System.out.println(<span class="string">&quot;nano:&quot;</span> + nano);</span><br><span class="line">System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">System.out.println(LocalTime.of(<span class="number">8</span>, <span class="number">20</span>));<span class="comment">//时分</span></span><br><span class="line">System.out.println(LocalTime.of(<span class="number">8</span>, <span class="number">20</span>, <span class="number">30</span>));<span class="comment">//时分秒</span></span><br><span class="line">System.out.println(LocalTime.of(<span class="number">8</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">150</span>));<span class="comment">//时分秒纳秒</span></span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">mTime</span> <span class="operator">=</span> LocalTime.of(<span class="number">8</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">150</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//is系列的方法</span></span><br><span class="line">System.out.println(nowTime.isBefore(mTime));</span><br><span class="line">System.out.println(nowTime.isAfter(mTime));</span><br><span class="line"></span><br><span class="line"><span class="comment">//with系列的方法，只能修改时、分、秒</span></span><br><span class="line">System.out.println(nowTime.withHour(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//plus系列的方法，只能修改时、分、秒</span></span><br><span class="line">System.out.println(nowTime.plusHours(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>



<h4 id="7-3-3-LocalDateTime-年、月、日、时、分、秒"><a href="#7-3-3-LocalDateTime-年、月、日、时、分、秒" class="headerlink" title="7.3.3 LocalDateTime  年、月、日、时、分、秒"></a>7.3.3 LocalDateTime  年、月、日、时、分、秒</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前时间的的日历对象(包含年月日时分秒)</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">nowDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;今天是:&quot;</span> + nowDateTime);<span class="comment">//今天是：</span></span><br><span class="line">System.out.println(nowDateTime.getYear());<span class="comment">//年</span></span><br><span class="line">System.out.println(nowDateTime.getMonthValue());<span class="comment">//月</span></span><br><span class="line">System.out.println(nowDateTime.getDayOfMonth());<span class="comment">//日</span></span><br><span class="line">System.out.println(nowDateTime.getHour());<span class="comment">//时</span></span><br><span class="line">System.out.println(nowDateTime.getMinute());<span class="comment">//分</span></span><br><span class="line">System.out.println(nowDateTime.getSecond());<span class="comment">//秒</span></span><br><span class="line">System.out.println(nowDateTime.getNano());<span class="comment">//纳秒</span></span><br><span class="line"><span class="comment">// 日:当年的第几天</span></span><br><span class="line">System.out.println(<span class="string">&quot;dayofYear:&quot;</span> + nowDateTime.getDayOfYear());</span><br><span class="line"><span class="comment">//星期</span></span><br><span class="line">System.out.println(nowDateTime.getDayOfWeek());</span><br><span class="line">System.out.println(nowDateTime.getDayOfWeek().getValue());</span><br><span class="line"><span class="comment">//月份</span></span><br><span class="line">System.out.println(nowDateTime.getMonth());</span><br><span class="line">System.out.println(nowDateTime.getMonth().getValue());</span><br><span class="line"></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">ld</span> <span class="operator">=</span> nowDateTime.toLocalDate();</span><br><span class="line">System.out.println(ld);</span><br><span class="line"></span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">lt</span> <span class="operator">=</span> nowDateTime.toLocalTime();</span><br><span class="line">System.out.println(lt.getHour());</span><br><span class="line">System.out.println(lt.getMinute());</span><br><span class="line">System.out.println(lt.getSecond());</span><br></pre></td></tr></table></figure>



<h3 id="7-4-工具类-Duration、Period、ChronoUnit"><a href="#7-4-工具类-Duration、Period、ChronoUnit" class="headerlink" title="7.4 工具类(Duration、Period、ChronoUnit)"></a>7.4 工具类(Duration、Period、ChronoUnit)</h3><h4 id="7-4-1-Duration-时间间隔（秒，纳，秒）"><a href="#7-4-1-Duration-时间间隔（秒，纳，秒）" class="headerlink" title="7.4.1 Duration  时间间隔（秒，纳，秒）"></a>7.4.1 Duration  时间间隔（秒，纳，秒）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 本地日期时间对象。</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">today</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">System.out.println(today);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出生的日期时间对象</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">birthDate</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2000</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">System.out.println(birthDate);</span><br><span class="line"></span><br><span class="line"><span class="type">Duration</span> <span class="variable">duration</span> <span class="operator">=</span> Duration.between(birthDate, today);<span class="comment">//第二个参数减第一个参数</span></span><br><span class="line">System.out.println(<span class="string">&quot;相差的时间间隔对象:&quot;</span> + duration);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;============================================&quot;</span>);</span><br><span class="line">System.out.println(duration.toDays());<span class="comment">//两个时间差的天数</span></span><br><span class="line">System.out.println(duration.toHours());<span class="comment">//两个时间差的小时数</span></span><br><span class="line">System.out.println(duration.toMinutes());<span class="comment">//两个时间差的分钟数</span></span><br><span class="line">System.out.println(duration.toMillis());<span class="comment">//两个时间差的毫秒数</span></span><br><span class="line">System.out.println(duration.toNanos());<span class="comment">//两个时间差的纳秒数</span></span><br></pre></td></tr></table></figure>

<h4 id="7-4-2-Period-时间间隔（年，月，日）"><a href="#7-4-2-Period-时间间隔（年，月，日）" class="headerlink" title="7.4.2 Period  时间间隔（年，月，日）"></a>7.4.2 Period  时间间隔（年，月，日）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前本地 年月日</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">System.out.println(today);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生日的 年月日</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">birthDate</span> <span class="operator">=</span> LocalDate.of(<span class="number">2000</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">System.out.println(birthDate);</span><br><span class="line"></span><br><span class="line"><span class="type">Period</span> <span class="variable">period</span> <span class="operator">=</span> Period.between(birthDate, today);<span class="comment">//第二个参数减第一个参数</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;相差的时间间隔对象:&quot;</span> + period);</span><br><span class="line">System.out.println(period.getYears());</span><br><span class="line">System.out.println(period.getMonths());</span><br><span class="line">System.out.println(period.getDays());</span><br><span class="line"></span><br><span class="line">System.out.println(period.toTotalMonths());</span><br></pre></td></tr></table></figure>

<h4 id="7-4-3-ChronoUnit-时间间隔（所有单位）-重点记"><a href="#7-4-3-ChronoUnit-时间间隔（所有单位）-重点记" class="headerlink" title="7.4.3 ChronoUnit  时间间隔（所有单位）(重点记)"></a>7.4.3 ChronoUnit  时间间隔（所有单位）(重点记)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前时间</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">today</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">System.out.println(today);</span><br><span class="line"><span class="comment">// 生日时间</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">birthDate</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2000</span>, <span class="number">1</span>, <span class="number">1</span>,<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">System.out.println(birthDate);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;相差的年数:&quot;</span> + ChronoUnit.YEARS.between(birthDate, today));</span><br><span class="line">System.out.println(<span class="string">&quot;相差的月数:&quot;</span> + ChronoUnit.MONTHS.between(birthDate, today));</span><br><span class="line">System.out.println(<span class="string">&quot;相差的周数:&quot;</span> + ChronoUnit.WEEKS.between(birthDate, today));</span><br><span class="line">System.out.println(<span class="string">&quot;相差的天数:&quot;</span> + ChronoUnit.DAYS.between(birthDate, today));</span><br><span class="line">System.out.println(<span class="string">&quot;相差的时数:&quot;</span> + ChronoUnit.HOURS.between(birthDate, today));</span><br><span class="line">System.out.println(<span class="string">&quot;相差的分数:&quot;</span> + ChronoUnit.MINUTES.between(birthDate, today));</span><br><span class="line">System.out.println(<span class="string">&quot;相差的秒数:&quot;</span> + ChronoUnit.SECONDS.between(birthDate, today));</span><br><span class="line">System.out.println(<span class="string">&quot;相差的毫秒数:&quot;</span> + ChronoUnit.MILLIS.between(birthDate, today));</span><br><span class="line">System.out.println(<span class="string">&quot;相差的微秒数:&quot;</span> + ChronoUnit.MICROS.between(birthDate, today));</span><br><span class="line">System.out.println(<span class="string">&quot;相差的纳秒数:&quot;</span> + ChronoUnit.NANOS.between(birthDate, today));</span><br><span class="line">System.out.println(<span class="string">&quot;相差的半天数:&quot;</span> + ChronoUnit.HALF_DAYS.between(birthDate, today));</span><br><span class="line">System.out.println(<span class="string">&quot;相差的十年数:&quot;</span> + ChronoUnit.DECADES.between(birthDate, today));</span><br><span class="line">System.out.println(<span class="string">&quot;相差的世纪(百年)数:&quot;</span> + ChronoUnit.CENTURIES.between(birthDate, today));</span><br><span class="line">System.out.println(<span class="string">&quot;相差的千年数:&quot;</span> + ChronoUnit.MILLENNIA.between(birthDate, today));</span><br><span class="line">System.out.println(<span class="string">&quot;相差的纪元数:&quot;</span> + ChronoUnit.ERAS.between(birthDate, today));</span><br></pre></td></tr></table></figure>



<h2 id="8-包装类"><a href="#8-包装类" class="headerlink" title="8. 包装类"></a>8. 包装类</h2><h3 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h3><p>Java提供了两个类型系统，<strong>基本类型</strong>与<strong>引用类型</strong>，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下：</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>对应的包装类（位于java.lang包中）</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td><strong>Integer</strong></td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>char</td>
<td><strong>Character</strong></td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody></table>
<p>包装类是引用数据类型,用一个对象,把基本数据类型给包起来</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img%5C%E5%8C%85%E8%A3%85%E7%B1%BB.jpg"></p>
<h3 id="8-2-Integer类"><a href="#8-2-Integer类" class="headerlink" title="8.2 Integer类"></a>8.2 Integer类</h3><ul>
<li><p>Integer类概述</p>
<p>包装一个对象中的原始类型 int 的值</p>
</li>
<li><p>Integer类构造方法及静态方法</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public Integer(int   value)</td>
<td>根据 int 值创建 Integer 对象(过时)</td>
</tr>
<tr>
<td>public Integer(String s)</td>
<td>根据 String 值创建 Integer 对象(过时)</td>
</tr>
<tr>
<td>public static Integer valueOf(int i)</td>
<td>返回表示指定的 int 值的 Integer   实例</td>
</tr>
<tr>
<td>public static Integer valueOf(String s)</td>
<td>返回保存指定String值的 Integer 对象</td>
</tr>
<tr>
<td>static string tobinarystring(int i)</td>
<td>得到二进制</td>
</tr>
<tr>
<td>static string tooctalstring(int i)</td>
<td>得到八进制</td>
</tr>
<tr>
<td>static string toHexstring(int i)</td>
<td>得到十六进制</td>
</tr>
<tr>
<td>static int parseInt(string s)</td>
<td>将字符串类型的整数转成int类型的整数</td>
</tr>
</tbody></table>
<p><strong>重点</strong>是最后一个方法 <strong>parseInt</strong>: 将<strong>字符串类型</strong>的整数转成<strong>int类型</strong>的整数</p>
<ul>
<li>示例代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//public static Integer valueOf(int i)：返回表示指定的 int 值的 Integer 实例</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> Integer.valueOf(<span class="number">100</span>);</span><br><span class="line">System.out.println(i3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//public static Integer valueOf(String s)：返回保存指定String值的Integer对象 </span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i4</span> <span class="operator">=</span> Integer.valueOf(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">System.out.println(i4);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//4.将字符串类型的整数转成int类型的整数</span></span><br><span class="line"><span class="comment">//强类型语言:每种数据在java中都有各自的数据类型</span></span><br><span class="line"><span class="comment">//在计算的时候，如果不是同一种数据类型，是无法直接计算的。</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">System.out.println(i);</span><br><span class="line">System.out.println(i + <span class="number">1</span>);<span class="comment">//124</span></span><br><span class="line"><span class="comment">//细节1:</span></span><br><span class="line"><span class="comment">//在类型转换的时候，括号中的参数只能是数字不能是其他，否则代码会报错</span></span><br><span class="line"><span class="comment">//细节2:</span></span><br><span class="line"><span class="comment">//8种包装类当中，除了Character都有对应的parseXxx的方法，进行类型转换</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;true&quot;</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> Boolean.parseBoolean(str);</span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure>

<h3 id="8-3-自动装箱与自动拆箱-JDK5以后对包装类新增了什么特性"><a href="#8-3-自动装箱与自动拆箱-JDK5以后对包装类新增了什么特性" class="headerlink" title="8.3 自动装箱与自动拆箱(JDK5以后对包装类新增了什么特性)"></a>8.3 自动装箱与自动拆箱(JDK5以后对包装类新增了什么特性)</h3><p><strong>自动装箱:</strong></p>
<p>​		把一个基本类型的数据直接赋值给对应的包装类型</p>
<p><strong>自动拆箱:</strong></p>
<p>​		把一个包装类型的对象直接赋值给对应的基本类型</p>
<p>由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">4</span>;<span class="comment">//自动装箱。相当于Integer i = Integer.valueOf(4);</span></span><br><span class="line">i = i + <span class="number">5</span>;<span class="comment">//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;</span></span><br><span class="line"><span class="comment">//加法运算完成后，再次装箱，把基本数值转成对象。</span></span><br></pre></td></tr></table></figure>

<p><strong>我们以后如何获取包装类对象?</strong></p>
<p>不需要new 不需要调用方法 <strong>直接赋值即可</strong></p>
<p><strong>Integer i &#x3D;10;</strong></p>
<h3 id="8-4-基本类型与字符串之间的转换"><a href="#8-4-基本类型与字符串之间的转换" class="headerlink" title="8.4 基本类型与字符串之间的转换"></a>8.4 基本类型与字符串之间的转换</h3><h4 id="8-4-1-基本类型转换为String"><a href="#8-4-1-基本类型转换为String" class="headerlink" title="8.4.1 基本类型转换为String"></a>8.4.1 基本类型转换为String</h4><ul>
<li>转换方式</li>
<li>方式一：直接在数字后<strong>加一个空字符串</strong></li>
<li>方式二：通过String类静态方法<strong>valueOf()</strong></li>
<li>示例代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntegerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//int --- String</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="comment">//方式1</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> number + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//方式2</span></span><br><span class="line">        <span class="comment">//public static String valueOf(int i)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> String.valueOf(number);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-4-2-String转换成基本类型"><a href="#8-4-2-String转换成基本类型" class="headerlink" title="8.4.2 String转换成基本类型"></a>8.4.2 String转换成基本类型</h4><p>除了Character类之外，其他所有包装类都具有<strong>parseXxx静态方法</strong>可以将字符串参数转换为对应的基本类型：</p>
<ul>
<li><code>public static byte parseByte(String s)</code>：将字符串参数转换为对应的byte基本类型。</li>
<li><code>public static short parseShort(String s)</code>：将字符串参数转换为对应的short基本类型。</li>
<li><strong><code>public static int parseInt(String s)</code>：将字符串参数转换为对应的int基本类型。</strong></li>
<li><strong><code>public static long parseLong(String s)</code>：将字符串参数转换为对应的long基本类型。</strong></li>
<li><code>public static float parseFloat(String s)</code>：将字符串参数转换为对应的float基本类型。</li>
<li><code>public static double parseDouble(String s)</code>：将字符串参数转换为对应的double基本类型。</li>
<li><code>public static boolean parseBoolean(String s)</code>：将字符串参数转换为对应的boolean基本类型。</li>
</ul>
<p>代码使用（仅以Integer类的静态方法parseXxx为例）如：</p>
<ul>
<li>转换方式<ul>
<li>方式一：先将字符串数字转成Integer，再调用valueOf()方法</li>
<li>方式二：<strong>通过Integer静态方法parseInt()进行转换(常用)</strong></li>
</ul>
</li>
<li>示例代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntegerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//String --- int</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;100&quot;</span>;</span><br><span class="line">        <span class="comment">//方式1：String --- Integer --- int</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Integer.valueOf(s);</span><br><span class="line">        <span class="comment">//public int intValue()</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> i.intValue();</span><br><span class="line">        System.out.println(x);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//方式2</span></span><br><span class="line">        <span class="comment">//public static int parseInt(String s)</span></span><br><span class="line">         <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;100&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> Integer.parseInt(s);</span><br><span class="line">        System.out.println(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出<code>java.lang.NumberFormatException</code>异常。</p>
</blockquote>
<h3 id="8-5-两种方式获取Integer对象的区别-面试"><a href="#8-5-两种方式获取Integer对象的区别-面试" class="headerlink" title="8.5 两种方式获取Integer对象的区别(面试)"></a>8.5 两种方式获取Integer对象的区别(面试)</h3><ol>
<li>利用<strong>构造方法</strong>获取Integer的对象<ol>
<li>在Java中，每一次<strong>new</strong>都是创建了一个新的对象</li>
<li>所以创建的对象<strong>都是new出来的，地址值不一样。</strong></li>
</ol>
</li>
<li>.利用**静态方法(valueOf)**获取Integer的对象<ol>
<li>如果参数<strong>范围在-128~127之间的</strong>,用到了,<strong>不会去重新创建</strong>对象 ,而是<strong>返回已经创建好的对象</strong>。<ol>
<li>因为在实际开发中，-128~127之间的数据，用的比较多。</li>
</ol>
</li>
<li>如果<strong>超出</strong>了范围,就会<strong>重新创建对象</strong></li>
</ol>
</li>
</ol>
<p>建议：<strong>获取Integer对象</strong>的时候不要自己new，而是采取<strong>直接赋值</strong>或者静态方法<strong>valueOf</strong>的方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.利用构造方法获取Integer的对象(JDK5以前的方式)</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.利用静态方法获取Integer的对象(JDK5以前的方式)</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> Integer.valueOf(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.这两种方式获取对象的区别(掌握)</span></span><br><span class="line"><span class="comment">//底层原理：</span></span><br><span class="line"><span class="comment">//因为在实际开发中，-128~127之间的数据，用的比较多。</span></span><br><span class="line"><span class="comment">//如果每次使用都是new对象，那么太浪费内存了</span></span><br><span class="line"><span class="comment">//所以，提前把这个范围之内的每一个数据都创建好对象</span></span><br><span class="line"><span class="comment">//如果要用到了不会创建新的，而是返回已经创建好的对象。</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i6</span> <span class="operator">=</span> Integer.valueOf(<span class="number">127</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i7</span> <span class="operator">=</span> Integer.valueOf(<span class="number">127</span>);</span><br><span class="line">System.out.println(i6 == i7);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i8</span> <span class="operator">=</span> Integer.valueOf(<span class="number">128</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i9</span> <span class="operator">=</span> Integer.valueOf(<span class="number">128</span>);</span><br><span class="line">System.out.println(i8 == i9);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//因为看到了new关键字，在Java中，每一次new都是创建了一个新的对象</span></span><br><span class="line"><span class="comment">//所以下面的两个对象都是new出来，地址值不一样。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">		Integer i10 = new Integer(127);</span></span><br><span class="line"><span class="comment">        Integer i11 = new Integer(127);</span></span><br><span class="line"><span class="comment">        System.out.println(i10 == i11);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        Integer i12 = new Integer(128);</span></span><br><span class="line"><span class="comment">        Integer i13 = new Integer(128);</span></span><br><span class="line"><span class="comment">        System.out.println(i12 == i13);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="9-Arrays"><a href="#9-Arrays" class="headerlink" title="9.Arrays"></a>9.Arrays</h2><p><strong>操作数组的工具类</strong></p>
<h3 id="9-1-方法"><a href="#9-1-方法" class="headerlink" title="9.1 方法"></a>9.1 方法</h3><ol>
<li>public static String <strong>toString</strong>(数组)               											<strong>把数组拼接成一个字符串</strong></li>
<li>public static int <strong>binarySearch</strong>(数组,查找的元素)                                   <strong>二分查找</strong>法查找元素</li>
<li>public static int[] <strong>copyOfRange</strong>(原数组,新数组长度)                            拷贝数组</li>
<li>public static int[] <strong>copyOfRange</strong>(原数组,起始索引,结束索引)                拷贝数组(指定范围)</li>
<li>public static void <strong>fill</strong>(数组,元素)                                                               填充数组</li>
<li>public static void <strong>sort</strong>(数组)                                                                     按照默认方式进行数组排序</li>
<li>public static void <strong>sort</strong>(数组,排序规则)                                                     按照指定的规则排序</li>
</ol>
<p>代码示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        <span class="comment">//toString 把数组变成字符串</span></span><br><span class="line">        System.out.println(Arrays.toString(arr));<span class="comment">//[1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//利用二分查找 查找元素</span></span><br><span class="line">        <span class="comment">//数组中的元素必须是有序的 而且必须是升序的</span></span><br><span class="line">        <span class="comment">//如果查找的元素时存在的  返回的是元素的索引值</span></span><br><span class="line">        <span class="comment">//如果查找的元素数组中不存在 返回的是 -插入点-1</span></span><br><span class="line">        <span class="comment">//插入点:如果元素存在,它应该在什么位置</span></span><br><span class="line">        System.out.println(Arrays.binarySearch(arr,<span class="number">8</span>));<span class="comment">//7</span></span><br><span class="line">        System.out.println(Arrays.binarySearch(arr, <span class="number">20</span>));<span class="comment">//-11</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//copyOf  拷贝数组</span></span><br><span class="line">        <span class="comment">//参数一:老数组</span></span><br><span class="line">        <span class="comment">//参数二:新数组的长度</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            方法的底层会根据第二个参数来创建新的数组</span></span><br><span class="line"><span class="comment">            如果新数组的长度小于老数组的长度,会部分拷贝</span></span><br><span class="line"><span class="comment">            如果新数组的长度等于老数组的长度,会完全拷贝</span></span><br><span class="line"><span class="comment">            如果新数组的长度大于老数组的长度,会补上默认初始值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span>[] newArr=Arrays.copyOf(arr,<span class="number">10</span>);</span><br><span class="line">        System.out.println(Arrays.toString(newArr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//copyOfRange拷贝数组 指定范围</span></span><br><span class="line">        <span class="comment">//包括左边的索引但不包括右边的索引</span></span><br><span class="line">        <span class="type">int</span>[] newArr2=Arrays.copyOfRange(arr,<span class="number">0</span>,<span class="number">9</span>);</span><br><span class="line">        System.out.println(Arrays.toString(newArr2));<span class="comment">//[1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//fill  填充数组 把所有位置的元素都填充成一个值</span></span><br><span class="line">        Arrays.fill(arr,<span class="number">100</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));<span class="comment">//[100, 100, 100, 100, 100, 100, 100, 100, 100, 100]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//sort 排序 默认情况下对数组进行升序排序 底层是快速排序</span></span><br><span class="line">        <span class="type">int</span>[] arr2=&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        Arrays.sort(arr2);</span><br><span class="line">        System.out.println(Arrays.toString(arr2));<span class="comment">//[1, 2, 3, 4, 5, 6, 7, 8]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果我们想要进行降序排列怎么办呢?</span></span><br><span class="line">        <span class="comment">//利用sort方法指定好规则</span></span><br><span class="line">        <span class="comment">//Arrays.sort(arr2,规则);</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        细节: 只能给引用数据类型的数组进行排序</span></span><br><span class="line"><span class="comment">        如果数组是基本数据类型的 需要变成其对应的包装类</span></span><br><span class="line"><span class="comment">        第二个参数是一个接口,我们在调用方法的时候,需要传递这个接口的实现类对象,作为排序的规则</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Integer[] arr3=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        Arrays.sort(arr3, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">                <span class="comment">//o1-o2:升序排列</span></span><br><span class="line">                <span class="comment">//o2-o1:降序排列</span></span><br><span class="line">                <span class="keyword">return</span> o2-o1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(arr3));<span class="comment">//[9, 8, 7, 6, 5, 4, 3, 2, 1]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="10-Lambda表达式"><a href="#10-Lambda表达式" class="headerlink" title="10.Lambda表达式"></a>10.Lambda表达式</h2><p><strong>作用:简化匿名内部类的书写</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] arr3=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">9</span>&#125;;</span><br><span class="line">      Arrays.sort(arr3, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">              <span class="comment">//o1-o2:升序排列</span></span><br><span class="line">              <span class="comment">//o2-o1:降序排列</span></span><br><span class="line">              <span class="keyword">return</span> o2-o1;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      System.out.println(Arrays.toString(arr3));<span class="comment">//[9, 8, 7, 6, 5, 4, 3, 2, 1]</span></span><br></pre></td></tr></table></figure>

<p>可以变成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] arr3=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">9</span>&#125;;</span><br><span class="line">      Arrays.sort(arr3, (Integer o1, Integer o2) -&gt; &#123;</span><br><span class="line">              <span class="comment">//o1-o2:升序排列</span></span><br><span class="line">              <span class="comment">//o2-o1:降序排列</span></span><br><span class="line">              <span class="keyword">return</span> o2-o1;</span><br><span class="line">          &#125;</span><br><span class="line">      );</span><br><span class="line">      System.out.println(Arrays.toString(arr3));<span class="comment">//[9, 8, 7, 6, 5, 4, 3, 2, 1]</span></span><br></pre></td></tr></table></figure>

<p><strong>函数式编程</strong></p>
<p>忽略面向对象的复杂语法,<strong>强调做什么,而不是谁去做</strong></p>
<p>我们要学习的<strong>Lambda表达式就是函数式思想的体现</strong></p>
<p><strong>注意:</strong></p>
<ul>
<li>Lambda表达式可以用来<strong>简化匿名内部类</strong>的书写</li>
<li>只能简化<strong>函数式接口</strong>的匿名内部类的写法</li>
<li>函数式接口:<br><strong>有且仅有一个抽象方法</strong>的接口叫做函数式接口<br> 接口上方可以加**@FunctionalInterface** 注解</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com_02.itheima_13;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        method(</span><br><span class="line">                ()-&gt;&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;正在游泳&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Swim s)</span>&#123;</span><br><span class="line">        s.swimming();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//必须是接口的匿名内部类,接口中只能有一个抽象方法</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Swim</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://xinyixy.github.io">zlf</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://xinyixy.github.io/2020/11/02/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E5%90%88/">https://xinyixy.github.io/2020/11/02/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E5%90%88/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://xinyixy.github.io" target="_blank">LAN</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</a><a class="post-meta__tags" href="/tags/%E7%B1%BB/">类</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="/pluginsSrc/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="/pluginsSrc/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/11/02/Java%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88/" title="Java基础-集合"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java基础-集合</div></div></a></div><div class="next-post pull-right"><a href="/2020/10/23/Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" title="Java基础语法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java基础语法</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">zlf</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xinyixy" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/1207733925@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-String%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">1. String类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-String%E7%B1%BB%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 String类的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-String%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 String类的构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-String%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 String类常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-equals%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.3.1 equals方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-charAt%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.2.</span> <span class="toc-text">1.3.2 charAt方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-4-replace%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.3.</span> <span class="toc-text">1.3.4 replace方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-StringBuilder"><span class="toc-number">2.</span> <span class="toc-text">2. StringBuilder</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-toString%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.1.1 toString方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-reverse%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2.2 reverse方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.</span> <span class="toc-text">3. 面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 static关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E7%BB%A7%E6%89%BF"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-super%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1  super访问父类成员变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-Override%E9%87%8D%E5%86%99%E6%B3%A8%E8%A7%A3"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2 @Override重写注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-%E7%BB%A7%E6%89%BF%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">3.2.3.</span> <span class="toc-text">3.2.3 继承的特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%A4%9A%E6%80%81"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 多态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E5%A4%9A%E6%80%81%E7%9A%84%E5%BD%A2%E5%BC%8F"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.1 多态的形式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%89%8D%E6%8F%90"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.2 多态的定义和前提</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E5%A4%9A%E6%80%81%E7%9A%84%E8%BF%90%E8%A1%8C%E7%89%B9%E7%82%B9"><span class="toc-number">3.3.3.</span> <span class="toc-text">3.3 多态的运行特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.3.4.</span> <span class="toc-text">3.4 引用类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-1-%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%EF%BC%88%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2%EF%BC%89"><span class="toc-number">3.3.4.1.</span> <span class="toc-text">3.4.1 向上转型（自动转换）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-2-%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B%EF%BC%88%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%EF%BC%89"><span class="toc-number">3.3.4.2.</span> <span class="toc-text">3.4.2 向下转型（强制转换）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-instanceof%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.3.5.</span> <span class="toc-text">3.5 instanceof关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-5-1-instanceof%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">3.3.5.1.</span> <span class="toc-text">3.5.1 instanceof新特性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 权限修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E4%B8%8D%E5%90%8C%E6%9D%83%E9%99%90%E7%9A%84%E8%AE%BF%E9%97%AE%E8%83%BD%E5%8A%9B"><span class="toc-number">3.4.1.</span> <span class="toc-text">3.1 不同权限的访问能力</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.5.</span> <span class="toc-text">3.5 final关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-1-final%E4%BF%AE%E9%A5%B0%E7%B1%BB"><span class="toc-number">3.5.1.</span> <span class="toc-text">3.5.1 final修饰类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-2-final%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95"><span class="toc-number">3.5.2.</span> <span class="toc-text">3.5.2 final修饰方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-3-final%E4%BF%AE%E9%A5%B0%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">3.5.3.</span> <span class="toc-text">3.5.3 final修饰局部变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-4-final%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">3.5.4.</span> <span class="toc-text">3.5.4 final修饰成员变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">3.6.</span> <span class="toc-text">3.6 静态代码块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">3.7.</span> <span class="toc-text">3.7 内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-1-%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">3.7.1.</span> <span class="toc-text">3.7.1 成员内部类面试题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-2-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB-%E9%87%8D%E7%82%B9"><span class="toc-number">3.7.2.</span> <span class="toc-text">3.7.2 匿名内部类(重点)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%89%8D%E6%8F%90%E5%92%8C%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.7.2.1.</span> <span class="toc-text">匿名内部类前提和格式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">3.7.2.2.</span> <span class="toc-text">匿名内部类的特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.7.2.3.</span> <span class="toc-text">匿名内部类的使用场景</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%B8%B8%E8%A7%81API"><span class="toc-number">4.</span> <span class="toc-text">4.常见API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-System%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 System类常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-Object%E7%B1%BB"><span class="toc-number">4.2.</span> <span class="toc-text">4 .2 Object类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">4.2.1.</span> <span class="toc-text">4.2.1 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.2.</span> <span class="toc-text">4.2.2 常见方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-toString"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">1. toString:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-equals%E6%96%B9%E6%B3%95-%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">4.2.2.2.</span> <span class="toc-text">2. equals方法(面试题)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%85%8B%E9%9A%86"><span class="toc-number">4.2.2.3.</span> <span class="toc-text">3. 克隆</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-Objects%E7%B1%BB"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 Objects类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.1.</span> <span class="toc-text">4.3.1 常见方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text">5. 正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%AD%97%E7%AC%A6%E7%B1%BB"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 正则表达式-字符类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 正则表达式-逻辑运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E9%A2%84%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 正则表达式-预定义字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E6%95%B0%E9%87%8F%E8%AF%8D"><span class="toc-number">5.4.</span> <span class="toc-text">5.4 正则表达式-数量词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%BB%83%E4%B9%A01"><span class="toc-number">5.5.</span> <span class="toc-text">5.5 正则表达式练习1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%BB%83%E4%B9%A02"><span class="toc-number">5.6.</span> <span class="toc-text">5.6 正则表达式练习2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-String%E7%9A%84split%E6%96%B9%E6%B3%95%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">5.7.</span> <span class="toc-text">5.7 String的split方法中使用正则表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8-String%E7%B1%BB%E7%9A%84replaceAll%E6%96%B9%E6%B3%95%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">5.8.</span> <span class="toc-text">5.8 String类的replaceAll方法中使用正则表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-9-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%88%86%E7%BB%84%E6%8B%AC%E5%8F%B7"><span class="toc-number">5.9.</span> <span class="toc-text">5.9 正则表达式-分组括号( )</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-10-%E5%88%86%E7%BB%84%E7%BB%83%E4%B9%A0"><span class="toc-number">5.10.</span> <span class="toc-text">5.10 分组练习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-11-%E5%BF%BD%E7%95%A5%E5%A4%A7%E5%B0%8F%E5%86%99%E7%9A%84%E5%86%99%E6%B3%95"><span class="toc-number">5.11.</span> <span class="toc-text">5.11 忽略大小写的写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-12-%E9%9D%9E%E6%8D%95%E8%8E%B7%E5%88%86%E7%BB%84"><span class="toc-number">5.12.</span> <span class="toc-text">5.12 非捕获分组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-13-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%BB%83%E4%B9%A0"><span class="toc-number">5.13.</span> <span class="toc-text">5.13 正则表达式练习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-JDK7%E7%9B%B8%E5%85%B3%E6%97%B6%E9%97%B4%E7%B1%BB"><span class="toc-number">6.</span> <span class="toc-text">6. JDK7相关时间类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-Date%E7%B1%BB"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 Date类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-1-Date%E7%B1%BB%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">6.1.1.</span> <span class="toc-text">6.1.1 Date类构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-2-Date%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">6.1.2.</span> <span class="toc-text">6.1.2 Date常用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-SimpleDateFormat%E7%B1%BB-%E6%97%A5%E6%9C%9F-x2F-%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 SimpleDateFormat类(日期&#x2F;时间格式化)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-1-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">6.2.1.</span> <span class="toc-text">6.2.1 构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-2-%E6%A0%BC%E5%BC%8F%E8%A7%84%E5%88%99"><span class="toc-number">6.2.2.</span> <span class="toc-text">6.2.2 格式规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-3-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">6.2.3.</span> <span class="toc-text">6.2.3 常用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-Calendar%E7%B1%BB-%E6%97%A5%E5%8E%86%E7%B1%BB"><span class="toc-number">6.3.</span> <span class="toc-text">6.3 Calendar类(日历类)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">6.3.1.</span> <span class="toc-text">6.3.1 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-2-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">6.3.2.</span> <span class="toc-text">6.3.2 常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-3-get%E6%96%B9%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.3.3.</span> <span class="toc-text">6.3.3 get方法示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-4-set%E6%96%B9%E6%B3%95%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-number">6.3.4.</span> <span class="toc-text">6.3.4 set方法示例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-5-add%E6%96%B9%E6%B3%95%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-number">6.3.5.</span> <span class="toc-text">6.3.5 add方法示例：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-JDK8%E7%9B%B8%E5%85%B3%E6%97%B6%E9%97%B4%E7%B1%BB"><span class="toc-number">7.</span> <span class="toc-text">7. JDK8相关时间类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-Date%E7%B1%BB-ZoneId%E3%80%81Instant%E3%80%81ZoneDateTime"><span class="toc-number">7.1.</span> <span class="toc-text">7.1 Date类(ZoneId、Instant、ZoneDateTime)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-1-ZoneId%E6%97%B6%E5%8C%BA"><span class="toc-number">7.1.1.</span> <span class="toc-text">7.1.1 ZoneId时区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-2-Instant-%E6%97%B6%E9%97%B4%E6%88%B3"><span class="toc-number">7.1.2.</span> <span class="toc-text">7.1.2  Instant 时间戳</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-3-ZoneDateTime-%E5%B8%A6%E6%97%B6%E5%8C%BA%E7%9A%84%E6%97%B6%E9%97%B4"><span class="toc-number">7.1.3.</span> <span class="toc-text">7.1.3 ZoneDateTime  带时区的时间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%B1%BB-DateTimeFormatter"><span class="toc-number">7.2.</span> <span class="toc-text">7.2 日期格式化类(DateTimeFormatter)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-1-DateTimeFormatter-%E7%94%A8%E4%BA%8E%E6%97%B6%E9%97%B4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%92%8C%E8%A7%A3%E6%9E%90"><span class="toc-number">7.2.1.</span> <span class="toc-text">7.2.1 DateTimeFormatter   用于时间的格式化和解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E6%97%A5%E5%8E%86%E7%B1%BB-LocalDate%E3%80%81LocalTime%E3%80%81LocalDateTime"><span class="toc-number">7.3.</span> <span class="toc-text">7.3 日历类(LocalDate、LocalTime、LocalDateTime)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-1-LocalDate-%E5%B9%B4%E3%80%81%E6%9C%88%E3%80%81%E6%97%A5"><span class="toc-number">7.3.1.</span> <span class="toc-text">7.3.1 LocalDate  年、月、日</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-2-LocalTime-%E6%97%B6%E3%80%81%E5%88%86%E3%80%81%E7%A7%92"><span class="toc-number">7.3.2.</span> <span class="toc-text">7.3.2 LocalTime  时、分、秒</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-3-LocalDateTime-%E5%B9%B4%E3%80%81%E6%9C%88%E3%80%81%E6%97%A5%E3%80%81%E6%97%B6%E3%80%81%E5%88%86%E3%80%81%E7%A7%92"><span class="toc-number">7.3.3.</span> <span class="toc-text">7.3.3 LocalDateTime  年、月、日、时、分、秒</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E5%B7%A5%E5%85%B7%E7%B1%BB-Duration%E3%80%81Period%E3%80%81ChronoUnit"><span class="toc-number">7.4.</span> <span class="toc-text">7.4 工具类(Duration、Period、ChronoUnit)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-1-Duration-%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94%EF%BC%88%E7%A7%92%EF%BC%8C%E7%BA%B3%EF%BC%8C%E7%A7%92%EF%BC%89"><span class="toc-number">7.4.1.</span> <span class="toc-text">7.4.1 Duration  时间间隔（秒，纳，秒）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-2-Period-%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94%EF%BC%88%E5%B9%B4%EF%BC%8C%E6%9C%88%EF%BC%8C%E6%97%A5%EF%BC%89"><span class="toc-number">7.4.2.</span> <span class="toc-text">7.4.2 Period  时间间隔（年，月，日）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-3-ChronoUnit-%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94%EF%BC%88%E6%89%80%E6%9C%89%E5%8D%95%E4%BD%8D%EF%BC%89-%E9%87%8D%E7%82%B9%E8%AE%B0"><span class="toc-number">7.4.3.</span> <span class="toc-text">7.4.3 ChronoUnit  时间间隔（所有单位）(重点记)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">8.</span> <span class="toc-text">8. 包装类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">8.1.</span> <span class="toc-text">8.1 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-Integer%E7%B1%BB"><span class="toc-number">8.2.</span> <span class="toc-text">8.2 Integer类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1-JDK5%E4%BB%A5%E5%90%8E%E5%AF%B9%E5%8C%85%E8%A3%85%E7%B1%BB%E6%96%B0%E5%A2%9E%E4%BA%86%E4%BB%80%E4%B9%88%E7%89%B9%E6%80%A7"><span class="toc-number">8.3.</span> <span class="toc-text">8.3 自动装箱与自动拆箱(JDK5以后对包装类新增了什么特性)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">8.4.</span> <span class="toc-text">8.4 基本类型与字符串之间的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-1-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%BAString"><span class="toc-number">8.4.1.</span> <span class="toc-text">8.4.1 基本类型转换为String</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-2-String%E8%BD%AC%E6%8D%A2%E6%88%90%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.4.2.</span> <span class="toc-text">8.4.2 String转换成基本类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E8%8E%B7%E5%8F%96Integer%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8C%BA%E5%88%AB-%E9%9D%A2%E8%AF%95"><span class="toc-number">8.5.</span> <span class="toc-text">8.5 两种方式获取Integer对象的区别(面试)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Arrays"><span class="toc-number">9.</span> <span class="toc-text">9.Arrays</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E6%96%B9%E6%B3%95"><span class="toc-number">9.1.</span> <span class="toc-text">9.1 方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">10.</span> <span class="toc-text">10.Lambda表达式</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/03/20/Vue/" title="Vue思维导图">Vue思维导图</a><time datetime="2022-03-20T04:30:29.000Z" title="发表于 2022-03-20 12:30:29">2022-03-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/03/03/Ajax/" title="Ajax思维导图">Ajax思维导图</a><time datetime="2022-03-03T02:35:29.000Z" title="发表于 2022-03-03 10:35:29">2022-03-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/02/03/jQuery/" title="JQuery思维导图">JQuery思维导图</a><time datetime="2022-02-03T03:05:29.000Z" title="发表于 2022-02-03 11:05:29">2022-02-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/07/13/Springboot%E5%9F%BA%E7%A1%80%E7%AF%87/" title="Springboot基础篇">Springboot基础篇</a><time datetime="2021-07-13T04:47:07.000Z" title="发表于 2021-07-13 12:47:07">2021-07-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/06/23/SSM-SpringMVC02/" title="SSM-SpringMVC02">SSM-SpringMVC02</a><time datetime="2021-06-23T06:03:58.000Z" title="发表于 2021-06-23 14:03:58">2021-06-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="running-time"></div><div class="copyright">&copy;2020 - 2023 By zlf</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to LAN の Tiny Home!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/pluginsSrc/@fancyapps/ui/dist/fancybox/fancybox.umd.js"></script><script src="/pluginsSrc/instant.page/instantpage.js" type="module"></script><script src="/pluginsSrc/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('/pluginsSrc/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('/pluginsSrc/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  const disqus_config = function () {
    this.page.url = 'https://xinyixy.github.io/2020/11/02/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E5%90%88/'
    this.page.identifier = '/2020/11/02/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E5%90%88/'
    this.page.title = 'Java基础知识点整合'
  }

  const disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  btf.addModeChange('disqus', disqusReset)

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Valine' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script>setInterval(()=>{let create_time=Math.round(new Date("2020-8-21-12:14:00").getTime()/1000);let timestamp=Math.round((new Date().getTime()+8*60*60*1000)/1000);let second=timestamp-create_time;let time=new Array(0,0,0,0,0);if(second>=365*24*3600){time[0]=parseInt(second/(365*24*3600));second%=365*24*3600}if(second>=24*3600){time[1]=parseInt(second/(24*3600));second%=24*3600}if(second>=3600){time[2]=parseInt(second/3600);second%=3600}if(second>=60){time[3]=parseInt(second/60);second%=60}if(second>0){time[4]=second}currentTimeHtml='小破站已经安全运行 '+time[0]+' 年 '+time[1]+' 天 '+time[2]+' 时 '+time[3]+' 分 '+time[4]+' 秒';var elementById=document.getElementById('running-time');if(elementById){elementById.innerHTML=currentTimeHtml}},1000);</script> <script async src="/js/title.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>